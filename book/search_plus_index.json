{"./":{"url":"./","title":"PHP","keywords":"","body":"PHP PHP 全称 PHP: Hypertext Preprocessor ，超文本预处理器。 它是一种被广泛应用的开源脚本语言，可以嵌入到 HTML 文档中去执行，主要适用于 Web 开发领域。 "},"docs/语言参考.html":{"url":"docs/语言参考.html","title":"语言参考","keywords":"","body":"语言参考 基本语法 PHP 标记 从 HTML 中分离 指令分隔符 注释 类型 Boolean 布尔类型 Integer 整型 Float 浮点型 String 字符串 Array 数组 Object 对象 Resource 资源类型 NULL Callable 可调用类型 类型转换的判别 变量 基本语法 变量范围 可变变量 来自 PHP 之外的变量 常量 基本语法 魔术常量 表达式 运算符 运算符优先级 算数运算符 赋值运算符 位运算符 比较运算符 错误控制运算符 执行运算符 递增递减运算符 逻辑运算符 字符串运算符 数组运算符 类型运算符 函数 用户自定义函数 函数的参数 返回值 可变函数 匿名函数 类与对象 基本语法 属性 类常量 类的自动加载 构造函数和析构函数 访问控制 对象继承 范围解析操作符 Static 关键字 抽象类 对象接口 Trait 匿名类 重载 遍历对象 魔术方法 Final 关键字 对象复制 对象比较 类型约束 后期静态绑定 对象和引用 对象序列化 命名空间 基本语法 定义子命名空间 在同一个文件中定义多个命名空间 使用命名空间 - 基础 命名空间和动态语言特征 namespace 关键字和 __NAMESPACE__ 魔术常量 使用命名空间 - 别名和导入 全局空间 使用命名空间 - 后备全局函数和常量 名称解析规则 Errors 异常处理 基本语法 扩展 PHP 内置的异常处理类 生成器 生成器总览 生成器语法 生成器与 Iterator 对象比较 引用的解释 引用是什么 引用不是什么 引用做什么 引用传递 引用返回 取消引用 引用定位 预定义变量 超全局变量 $GLOBALS $_GET $_POST $_COOKIE $_REQUEST $_FILES $_SESSION $_SERVER $_ENV $http_response_header $argc $argv 预定义异常 Exception ErrorException 预定义接口 Traversable Iterator IteratorAggregate ArrayAccess Serializable Closure Generator 上下文选项和参数 套接字上下文选项 HTTP 上下文选项 FTP 上下文选项 SSL 上下文选项 CURL 上下文选项 Phar 上下文选项 MongoDB 上下文选项 Context 参数 支持的协议和封装协议 file:// http:// ftp:// php:// zlib:// data:// global:// phar:// ssh2:// rar:// ogg:// expect:// "},"docs/语言参考/基本语法.html":{"url":"docs/语言参考/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 PHP 标记 从 HTML 中分离 指令分隔符 注释 "},"docs/语言参考/基本语法/PHP 标记.html":{"url":"docs/语言参考/基本语法/PHP 标记.html","title":"PHP 标记","keywords":"","body":"PHP 标记 当解析一个文件时，PHP 会寻找起始标记和结束标记，也就是 和 ?> ，这告诉 PHP 开始和停止解析二者之间的代码。这种解析方式使得 PHP 可以被嵌入到各种不同的文档中去，而任何起始标记和结束标记之外的部分都会被 PHP 解析器忽略。 如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。 "},"docs/语言参考/基本语法/从 HTML 中分离.html":{"url":"docs/语言参考/基本语法/从 HTML 中分离.html","title":"从 HTML 中分离","keywords":"","body":"从 HTML 中分离 凡是在一对起始标记和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。可以使 PHP 嵌入到 HTML 文档中去。 Hello, World! Hello, World! 当处于条件语句中间时，此时 PHP 解释器会根据条件判断来决定哪些输出哪些跳过。 PHP 将跳过条件语句未达成的段落，即使该段落位于 PHP 开始和结束标记之外。由于 PHP 解释器会在条件未达成时直接跳过该段条件语句块，因此 PHP 会根据条件来忽略之。要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 echo 或 print 输出更有效率。 Hello, World! PHP "},"docs/语言参考/基本语法/指令分隔符.html":{"url":"docs/语言参考/基本语法/指令分隔符.html","title":"指令分隔符","keywords":"","body":"指令分隔符 PHP 需要在每个语句后用分号结束指令。 一段 PHP 代码中的结束标记隐含表示了一个分号。在一个 PHP 代码段中的最后一行可以不用分号结束。如果后面还有新行，则代码段的结束标记包含了行结束。 "},"docs/语言参考/基本语法/注释.html":{"url":"docs/语言参考/基本语法/注释.html","title":"注释","keywords":"","body":"注释 单行注释仅仅注释到行末或者当前的 PHP 代码块，视乎哪个首先出现。 多行注释在碰到第一个 */ 时结束。要确保不要嵌套多行注释，试图注释掉一大块代码时很容易出现该错误。 "},"docs/语言参考/类型.html":{"url":"docs/语言参考/类型.html","title":"类型","keywords":"","body":"类型 Boolean 布尔类型 Integer 整型 Float 浮点型 String 字符串 Array 数组 Object 对象 Resource 资源类型 NULL Callable 可调用类型 类型转换的判别 "},"docs/语言参考/类型/Boolean 布尔类型.html":{"url":"docs/语言参考/类型/Boolean 布尔类型.html","title":"Boolean 布尔类型","keywords":"","body":"Boolean 布尔类型 要指定一个布尔类型值，使用常量 true 或 false 。 通常运算符所返回的布尔类型值结果会被传递给流程控制。 转换为布尔类型： "},"docs/语言参考/类型/Integer 整型.html":{"url":"docs/语言参考/类型/Integer 整型.html","title":"Integer 整型","keywords":"","body":"Integer 整型 整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号 - 或者 + 。要使用十六进制表达，数字前必须加上 0x 。要使用八进制表达，数字前必须加上 0 。要使用二进制表达，数字前必须加上 0b 。 转换为整型： 注意，绝不要将未知的浮点型值强制转换为整型值，这样会导致不可预料的结果。 这是因为以十进制能够精确表示的有理数如 0.1 或 0.7 ，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点精度的情况下转换为二进制的格式。 "},"docs/语言参考/类型/Float 浮点型.html":{"url":"docs/语言参考/类型/Float 浮点型.html","title":"Float 浮点型","keywords":"","body":"Float 浮点型 浮点型，也叫浮点数，双精度数或实数，可以用以下任一语法定义： 转换为浮点型： "},"docs/语言参考/类型/String 字符串.html":{"url":"docs/语言参考/类型/String 字符串.html","title":"String 字符串","keywords":"","body":"String 字符串 定义一个字符串的最简单的方法是用单引号 '' 把它包围起来。 要表达一个单引号自身，需在它的前面加个反斜线 \\ 来转义。要表达一个反斜线自身，则用两个反斜线 \\\\ 。其它任何方式的反斜线都会被当成反斜线本身。也就是说如果想使用其它转义序列例如 \\r 或者 \\n ，并不代表任何特殊含义，就单纯是这两个字符本身。 如果字符串是包围在双引号 \"\" 中， PHP 将对一些特殊的字符进行解析。 另一种表达字符串的方法是用 Heredoc 句法结构： 。在该运算符之后要提供一个标识符，然后换行。接下来是字符串本身，最后要用前面定义的标识符作为结束标志。标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。 Heredoc 结构就像是没有使用双引号的双引号字符串，这就是说在 Heredoc 结构中单引号不用被转义，但是转义序列还可以使用。变量将被替换，但在 Heredoc 结构中含有复杂的变量时要格外小心。 就像 Heredoc 结构类似于双引号字符串， Nowdoc 结构是类似于单引号字符串的。 Nowdoc 结构很像 Heredoc 结构，但是 Nowdoc 中不进行解析操作。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。一个 Nowdoc 结构也和 Heredoc 结构用一样的标记 ，但是跟在后面的标识符要用单引号括起来，即 。 Heredoc 结构的所有规则也同样适用于 Nowdoc 结构。 当 PHP 解析器遇到一个美元符号 $ 时，它会和其它很多解析器一样，去组合尽量多的标识以形成一个合法的变量名。 一个数组索引也可以被解析，数组索引要用方括号 ] 来表示索引结束的边际。 'cat', 'dog', 'bird']; var_dump(\"foo bar $foo[foo]baz qux\"); // string(18) \"foo bar catbaz qux\" var_dump(\"foo bar $foo[0] baz qux\"); // string(19) \"foo bar dog baz qux\" var_dump(\"foo bar $foo[1] baz qux\"); // string(20) \"foo bar bird baz qux\" var_dump(\"foo bar $foo[0]baz qux\"); // string(18) \"foo bar dogbaz qux\" var_dump(\"foo bar $foo[1]baz qux\"); // string(19) \"foo bar birdbaz qux\" 一个对象属性也可被解析，对象属性则是和上述的变量规则相同。 property baz qux\"); // string(19) \"foo bar foo baz qux\" var_dump(\"foo bar $foo->propertybaz qux\"); // string(12) \"foo bar qux\" 复杂语法不是因为其语法复杂而得名，而是因为它可以使用复杂的表达式。只需简单地像在字符串以外的地方那样写出表达式，然后用花括号 {} 把它括起来即可。由于 { 无法被转义，只有 $ 紧挨着 { 时才会被识别。可以用 {\\$ 来表达 {$ 。 数组索引可以使用复杂语法解析。 'cat', 'dog', 'bird']; var_dump(\"foo bar {$foo['foo']}baz qux\"); // string(18) \"foo bar catbaz qux\" var_dump(\"foo bar {$foo[0]} baz qux\"); // string(19) \"foo bar dog baz qux\" var_dump(\"foo bar {$foo[1]} baz qux\"); // string(20) \"foo bar bird baz qux\" var_dump(\"foo bar {$foo[0]}baz qux\"); // string(18) \"foo bar dogbaz qux\" var_dump(\"foo bar {$foo[1]}baz qux\"); // string(19) \"foo bar birdbaz qux\" 对象属性也可以使用复杂语法解析。 property} baz qux\"); // string(19) \"foo bar foo baz qux\" var_dump(\"foo bar {$foo->property}baz qux\"); // string(18) \"foo bar foobaz qux\" 字符串中的字符可以通过一个从 0 开始的下标，用类似数组结构中的方括号包含对应的数字来访问。 也可以用类似数组结构中的方括号包含对应的数字来修改。 字符串下标必须为整数或可转换为整数的字符串，否则会发出警告并转换成 0 。 转换为字符串： "},"docs/语言参考/类型/Array 数组.html":{"url":"docs/语言参考/类型/Array 数组.html","title":"Array 数组","keywords":"","body":"Array 数组 可以用 array() 语言结构来新建一个数组。它接受任意数量用逗号分隔的键值对。最后一个数组单元之后的逗号可以省略。 'cat', 'bar' => 'dog' ); 还可以使用短数组定义语法，用 [] 替代 array() 。 'cat', 'bar' => 'dog' ]; 数组的键名可以是整型或者字符串。数组的值可以是任意类型。 此外数组的键会有如下的强制转换： 包含有合法整型值的字符串会被转换为整型，例如键名 \"8\" 实际会被储存为 8 ，但是 \"08\" 则不会强制转换，因为其不是一个合法的十进制数值。 浮点类型也会被转换为整型，意味着其小数部分会被舍去，例如键名 8.7 实际会被储存为 8 。 布尔类型也会被转换成整型，即键名 true 实际会被储存为 1 ，而键名 false 会被储存为 0 。 NULL 会被转换为空字符串，即键名 NULL 实际会被储存为 \"\" 。 数组和对象不能被用为键名，坚持这么做会导致警告。 如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。 'foo', '1' => 'bar', 1.5 => 'baz', true => 'qux' ]; var_dump($foo); // array(1) { [1]=> string(3) \"qux\" } 如果对给出的值没有指定键名，则取当前最大的整数索引值，新的键名将是该值加一。如果指定的键名已经有了值，则该值会被覆盖。 'baz', 'qux']; var_dump($foo); // array(4) { [0]=> string(3) \"foo\" [1]=> string(3) \"bar\" [6]=> string(3) \"baz\" [7]=> string(3) \"qux\" } 可以用直接对函数或方法调用的结果进行数组解引用。 要修改数组中的某个键值，通过其键名给该单元赋一个新值。 'cat', 'bar' => 'dog' ]; $foo['bar'] = 'cat'; var_dump($foo); // array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"cat\" } 也可以省略键名，在这种情况下给变量名加上一对空的方括号 [] 。 'cat', 'bar' => 'dog' ]; $foo[] = 'bird'; var_dump($foo); // array(3) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [0]=> string(4) \"bird\" } 要删除某键值对，对其调用 unset() 函数。 'cat', 'bar' => 'dog' ]; unset($foo['foo']); var_dump($foo); // array(1) { [\"bar\"]=> string(3) \"dog\" } 最大整数键名不一定当前就在数组中，它只要在上次数组重新生成索引后曾经存在过就行了。 int(1) [1]=> int(2) [2]=> int(3) [3]=> int(4) [4]=> int(5) } foreach ($foo as $key => $value) { unset($foo[$key]); } var_dump($foo); // array(0) { } $foo[] = 6; var_dump($foo); // array(1) { [5]=> int(6) } $foo = array_values($foo); $foo[] = 7; var_dump($foo); // array(2) { [0]=> int(6) [1]=> int(7) } 直接改变数组的值可以通过引用传递来做到。 int(3) [1]=> int(5) [2]=> int(6) } 转换为数组： bool(true) } var_dump((array) false); // array(1) { [0]=> bool(false) } var_dump((array) 0); // array(1) { [0]=> int(0) } var_dump((array) 1); // array(1) { [0]=> int(1) } var_dump((array) 1.001); // array(1) { [0]=> float(1.001) } var_dump((array) 'foo'); // array(1) { [0]=> string(3) \"foo\" } var_dump((array) new Foo); // array(0) { } var_dump((array) new Bar); // array(3) { [\"public\"]=> string(6) \"public\" [\"\\0*\\0protected\"]=> string(9) \"protected\" [\"\\0Bar\\0private\"]=> NULL } "},"docs/语言参考/类型/Object 对象.html":{"url":"docs/语言参考/类型/Object 对象.html","title":"Object 对象","keywords":"","body":"Object 对象 要创建一个新的对象，使用 new 语句实例化一个类。 转换为对象： string(3) \"foo\" } var_dump((object) [2, 4, 5]); // object(stdClass)#1 (3) { [\"0\"]=> int(2) [\"1\"]=> int(4) [\"2\"]=> int(5) } var_dump((object) ['foo' => 'cat', 'bar' => 'dog']); // object(stdClass)#1 (2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } "},"docs/语言参考/类型/Resource 资源类型.html":{"url":"docs/语言参考/类型/Resource 资源类型.html","title":"Resource 资源类型","keywords":"","body":"Resource 资源类型 资源是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。 "},"docs/语言参考/类型/NULL.html":{"url":"docs/语言参考/类型/NULL.html","title":"NULL","keywords":"","body":"NULL 特殊的 NULL 类型表示一个变量没有值。 NULL 类型唯一可能的值就是 NULL 。 在下列情况下一个变量被认为是 NULL ： 尚未被赋值。 被赋值为 NULL 。 被 unset() 。 "},"docs/语言参考/类型/Callable 可调用类型.html":{"url":"docs/语言参考/类型/Callable 可调用类型.html","title":"Callable 可调用类型","keywords":"","body":"Callable 可调用类型 用户自定义函数。 匿名函数。 类中的普通方法。 类中的静态方法。 父类中的静态方法。 类中的 __invoke() 魔术方法。 "},"docs/语言参考/类型/类型转换的判别.html":{"url":"docs/语言参考/类型/类型转换的判别.html","title":"类型转换的判别","keywords":"","body":"类型转换的判别 PHP 在变量定义中不需要或不支持明确的类型定义。变量类型是根据使用该变量的上下文所决定的。也就是说，如果把一个字符串值赋给一个变量，这个变量就成了一个字符串。如果又把一个整型赋给这个变量，那它就成了一个整型。PHP 的自动类型转换的一个例子是乘法运算符 * 。如果任何一个操作数是浮点型，则所有的操作数都被当成浮点型，结果也是浮点型。 否则操作数会被解释为整型，结果也是整型。注意这并没有改变这些操作数本身的类型，改变的仅是这些操作数如何被求值以及表达式本身的类型。 当一个字符串被当作一个数值来取值，如果该字符串没有包含 . 、 e 或 E 并且其数字值在整型的范围之内，该字符串将被当成整型来取值。其它所有情况下都被作为浮点型来取值。该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0 。合法数值由可选的正负号，后面跟着一个或多个数字，可能有小数点，再跟着可选的指数部分。指数部分由 e 或 E 后面跟着一个或多个数字构成。 "},"docs/语言参考/变量.html":{"url":"docs/语言参考/变量.html","title":"变量","keywords":"","body":"变量 基本语法 变量范围 可变变量 来自 PHP 之外的变量 "},"docs/语言参考/变量/基本语法.html":{"url":"docs/语言参考/变量/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 PHP 中的变量用一个美元符号 $ 后面跟变量名来表示。变量名是区分大小写的。变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。 以下划线开头，合法。 变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。 PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用了原始变量。改动新的变量将影响到原始变量，反之亦然。 "},"docs/语言参考/变量/变量范围.html":{"url":"docs/语言参考/变量/变量范围.html","title":"变量范围","keywords":"","body":"变量范围 变量的范围即它定义的上下文背景，也就是它的生效范围。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了引入的文件。 上例中的 example.php 文件内容： 在用户自定义函数中，一个局部函数范围将被引入。任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。 PHP 中全局变量在函数中使用时必须将变量声明为 global ，在函数中声明了全局变量之后，对任一变量的所有引用都会指向其全局版本。 在局部函数范围内访问全局变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 $GLOBALS 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容。 $GLOBALS 之所以在全局范围内存在，是因为 $GLOBALS 是一个超全局变量。 变量范围的另一个重要特性是静态变量。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。 静态变量也提供了一种处理递归函数的方法。递归函数是一种调用自己的函数。写递归函数时要小心，因为可能会无穷递归下去。必须确保有充分的方法来中止递归。 "},"docs/语言参考/变量/可变变量.html":{"url":"docs/语言参考/变量/可变变量.html","title":"可变变量","keywords":"","body":"可变变量 有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。 要将可变变量用于数组，必须解决一个模棱两可的问题。 类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。 $bar); // string(3) \"BAR\" var_dump($foo->{$baz}[2]); // string(3) \"BAZ\" var_dump($foo->{$qux[1]}); // string(3) \"BAR\" "},"docs/语言参考/变量/来自 PHP 之外的变量.html":{"url":"docs/语言参考/变量/来自 PHP 之外的变量.html","title":"来自 PHP 之外的变量","keywords":"","body":"来自 PHP 之外的变量 当一个表单提交给 PHP 脚本时，表单中的信息会自动在脚本中可用。 Login 上例中的 example.php 文件内容： 变量名中的点和空格被转换成下划线。 Submit 上例中的 example.php 文件内容： PHP 也懂得表单变量上下文中的数组。例如可以将相关的变量编成组，或者用此特性从多选输入框中取得值。 1 2 3 4 Submit 上例中的 example.php 文件内容： 当提交表单时，可以用一幅图像代替标准的提交按钮。当用户点击到图像中的某处时，相应的表单会被传送到服务器，并加上两个变量，它们包含了用户点击图像的坐标。有经验的用户可能会注意到被浏览器发送的实际变量名包含的是一个点而不是下划线，但 PHP 自动将点转换成了下划线。 上例中的 example.php 文件内容： PHP 透明地支持 RFC 6265 定义中的 HTTP Cookie 。 Cookie 是一种在浏览器端存储数据并能追踪或识别再次访问的用户的机制。可以用 setcookie() 函数设定 Cookie 。 Cookie 是 HTTP 信息头中的一部分，因此 setcookie() 函数必须在向浏览器发送任何输出之前调用。 "},"docs/语言参考/常量.html":{"url":"docs/语言参考/常量.html","title":"常量","keywords":"","body":"常量 基本语法 魔术常量 "},"docs/语言参考/常量/基本语法.html":{"url":"docs/语言参考/常量/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 常量是一个简单值的标识符。如同其名称所暗示的，在脚本执行期间该值不能改变，除了所谓的魔术常量，它们其实不是常量。常量默认为大小写敏感，传统上常量标识符总是大写的。常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。如果使用了一个未定义的常量， PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样。此时将发出一个 E_NOTICE 级的错误。 常量和变量有如下不同： 常量前面没有美元符号 $ 。 常量只能用 define() 函数或 const 关键字定义，而不能通过赋值语句。 常量可以不用理会变量的作用域而在任何地方定义和访问。 常量一旦定义就不能被重新定义或者取消定义。 常量的值只能是标量，数组或资源。 bool(true) [1]=> bool(false) } var_dump(QUX); // resource(4) of type (stream) 也可以使用 const 关键字定义常量，但必须处于最顶端的作用区域。 "},"docs/语言参考/常量/魔术常量.html":{"url":"docs/语言参考/常量/魔术常量.html","title":"魔术常量","keywords":"","body":"魔术常量 __LINE__ 用来获取文件中的当前行号。 __FILE__ 用来获取当前文件的完整路径和文件名。 __DIR__ 用来获取当前文件所在的目录。 __FUNCTION__ 用来获取当前函数的名称。 __CLASS__ 用来获取当前类的名称。 __TRAIT__ 用来获取当前 Trait 的名称。 __METHOD__ 用来获取当前类的方法名。 __NAMESPACE__ 用来获取当前命名空间的名称（区分大小写）。 "},"docs/语言参考/表达式.html":{"url":"docs/语言参考/表达式.html","title":"表达式","keywords":"","body":"表达式 表达式是 PHP 最重要的基石。在 PHP 中，几乎所写的任何东西都是一个表达式。 稍微复杂的表达式例子就是函数。 这里还涉及到一个额外的值，即赋值语句本身的值，赋值语句本身求值为被赋的值。 …… "},"docs/语言参考/运算符.html":{"url":"docs/语言参考/运算符.html","title":"运算符","keywords":"","body":"运算符 运算符优先级 算数运算符 赋值运算符 位运算符 比较运算符 错误控制运算符 执行运算符 递增递减运算符 逻辑运算符 字符串运算符 数组运算符 类型运算符 "},"docs/语言参考/运算符/运算符优先级.html":{"url":"docs/语言参考/运算符/运算符优先级.html","title":"运算符优先级","keywords":"","body":"运算符优先级 运算符优先级指定了两个表达式绑定得有多紧密。如果运算符优先级相同，那运算符的结合方向决定了该如何运算。没有结合的相同优先级的运算符不能连在一起使用。括号的使用，哪怕在不是必要的场合下，通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。下表按照优先级从高到低列出了运算符。同一行中的运算符具有相同优先级，此时它们的结合方向决定求值顺序。 结合方向 运算符 无 clone new 左 [ 右 ** 右 ++ -- ~ (int) (float) (string) (array) (object) (bool) @ 无 instanceof 右 ! 左 * / % 左 + - . 左 > 无 >= 无 == != <> === !== 左 & 左 ^ 左 | 左 && 左 || 左 ?? 左 ?: 右 = += -= *= /= %= **= .= &= |= ^= >= ??= 左 and 左 xor 左 or 算数运算符是左联的。 赋值运算符是右联的。 递增运算符优先级高于算数运算符和赋值运算符。 "},"docs/语言参考/运算符/算数运算符.html":{"url":"docs/语言参考/运算符/算数运算符.html","title":"算数运算符","keywords":"","body":"算数运算符 取反运算符 - 返回一个数的负值。 加法运算符 + 返回两个数相加的和。 减法运算符 - 返回两个数相减的差。 乘法运算符 * 返回两个数相乘的积。 除法运算符 / 总是返回浮点数。只有在两个操作数都是整数（或字符串转换成的整数）并且正好能整除，这时它返回一个整数。 取模运算符 % 的操作数在运算之前都会转换成整数（除去小数部分）。取模运算符 % 的结果和被除数的符号（正负号）相同。 幂运算符 ** 返回一个数指定次方的幂。 "},"docs/语言参考/运算符/赋值运算符.html":{"url":"docs/语言参考/运算符/赋值运算符.html","title":"赋值运算符","keywords":"","body":"赋值运算符 基本的赋值运算符是 = 。它意味着把右边表达式的值赋给左边的运算数。注意赋值运算将原变量的值拷贝到新变量中（传值赋值），所以改变其中一个并不影响另一个。在 PHP 中普通的传值赋值行为有个例外就是碰到对象时，在 PHP 中是以引用赋值的。 PHP 支持引用赋值，引用赋值意味着两个变量指向了同一个数据，没有拷贝任何东西。 "},"docs/语言参考/运算符/位运算符.html":{"url":"docs/语言参考/运算符/位运算符.html","title":"位运算符","keywords":"","body":"位运算符 按位与运算符 & 把两个数中都为 1 的位设为 1 。 (00000000 00000000 00000000 00000000) => int(0) var_dump(2 & 5); // (00000000 00000000 00000000 00000010) & (00000000 00000000 00000000 00000101) => (00000000 00000000 00000000 00000000) => int(0) var_dump(-4 & 5); // (11111111 11111111 11111111 11111100) & (00000000 00000000 00000000 00000101) => (00000000 00000000 00000000 00000100) => int(4) var_dump(-8 & -5); // (11111111 11111111 11111111 11111000) & (11111111 11111111 11111111 11111011) => (11111111 11111111 11111111 11111000) => int(-8) $foo = -8; // (11111111 11111111 11111111 11111000) $bar = -5; // (11111111 11111111 11111111 11111011) $foo &= $bar; // (11111111 11111111 11111111 11111000) var_dump($foo); // int(-8) 按位或运算符 | 把两个数中任何一个为 1 的位设为 1 。 (00000000 00000000 00000000 00000101) => int(5) var_dump(2 | 5); // (00000000 00000000 00000000 00000010) | (00000000 00000000 00000000 00000101) => (00000000 00000000 00000000 00000111) => int(7) var_dump(-4 | 5); // (11111111 11111111 11111111 11111100) | (00000000 00000000 00000000 00000101) => (11111111 11111111 11111111 11111101) => int(-3) var_dump(-8 | -5); // (11111111 11111111 11111111 11111000) | (11111111 11111111 11111111 11111011) => (11111111 11111111 11111111 11111011) => int(-5) $foo = -8; // (11111111 11111111 11111111 11111000) $bar = -5; // (11111111 11111111 11111111 11111011) $foo |= $bar; // (11111111 11111111 11111111 11111011) var_dump($foo); // int(-5) 按位异或运算符 ^ 把两个数中一个为 1 另一个为 0 的位设为 1 。 (00000000 00000000 00000000 00000101) => int(5) var_dump(2 ^ 5); // (00000000 00000000 00000000 00000010) ^ (00000000 00000000 00000000 00000101) => (00000000 00000000 00000000 00000111) => int(7) var_dump(-4 ^ 5); // (11111111 11111111 11111111 11111100) ^ (00000000 00000000 00000000 00000101) => (11111111 11111111 11111111 11111001) => int(-7) var_dump(-8 ^ -5); // (11111111 11111111 11111111 11111000) ^ (11111111 11111111 11111111 11111011) => (00000000 00000000 00000000 00000011) => int(3) $foo = -8; // (11111111 11111111 11111111 11111000) $bar = -5; // (11111111 11111111 11111111 11111011) $foo ^= $bar; // (00000000 00000000 00000000 00000011) var_dump($foo); // int(3) 按位取反运算符 ~ 把一个数中为 0 的位设为 1 ，为 1 的位设为 0 。 (11111111 11111111 11111111 11111111) => int(-1) var_dump(~2); // (00000000 00000000 00000000 00000010) => (11111111 11111111 11111111 11111101) => int(-3) var_dump(~-4); // (11111111 11111111 11111111 11111100) => (00000000 00000000 00000000 00000011) => int(3) var_dump(~-8); // (11111111 11111111 11111111 11111000) => (00000000 00000000 00000000 00000111) => int(7) 按位左移运算符 把一个数的位向左移动指定的位数。左移时右侧以零填充，符号位被移走意味着正负号不被保留。 (00000000 00000000 00000000 00000000) => int(0) var_dump(2 (00000000 00000000 00000000 00001000) => int(8) var_dump(-4 (11111111 11111111 11111111 11110000) => int(-16) var_dump(-8 (11111111 11111111 11111111 11100000) => int(-32) $foo = -8; // (11111111 11111111 11111111 11111000) $foo 按位右移运算符 >> 把一个数的位向右移动指定的位数。右移时左侧以符号位填充，意味着正负号被保留。 > 2); // (00000000 00000000 00000000 00000000) => (00000000 00000000 00000000 00000000) => int(0) var_dump(2 >> 2); // (00000000 00000000 00000000 00000010) => (00000000 00000000 00000000 00000000) => int(0) var_dump(-4 >> 2); // (11111111 11111111 11111111 11111100) => (11111111 11111111 11111111 11111111) => int(-1) var_dump(-8 >> 2); // (11111111 11111111 11111111 11111000) => (11111111 11111111 11111111 11111110) => int(-2) $foo = -8; // (11111111 11111111 11111111 11111000) $foo >>= 2; // (11111111 11111111 11111111 11111110) var_dump($foo); // int(-2) "},"docs/语言参考/运算符/比较运算符.html":{"url":"docs/语言参考/运算符/比较运算符.html","title":"比较运算符","keywords":"","body":"比较运算符 等于运算符 == 返回两个值类型转换后是否相等。如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。 以上规则同样也适用于 switch 语句。 全等运算符 === 返回两个值的类型和数值是否相等。 不等运算符 != 返回两个值类型转换后是否不等。 不全等运算符 !== 返回两个值的类型或数值是否不等。 小于运算符 返回一个值是否严格小于另一个值。 大于运算符 > 返回一个值是否严格大于另一个值。 3); // bool(false) var_dump(10 > 3); // bool(true) var_dump('foo' > 3); // bool(false) var_dump('0010' > 3); // bool(true) 小于等于运算符 返回一个值是否小于或等于另一个值。 大于等于运算符 >= 返回一个值是否大于或等于另一个值。 = 3); // bool(true) var_dump(10 >= 3); // bool(true) var_dump('foo' >= 3); // bool(false) var_dump('0010' >= 3); // bool(true) 太空船运算符（组合比较符） 当一个值小于、等于、大于另一个值时分别返回一个小于、等于、大于 0 的整数。 1); // int(0) var_dump(2 1); // int(1) var_dump(1 2); // int(-1) var_dump('foo' 'foo'); // int(0) var_dump('foo' 'bar'); // int(1) var_dump('bar' 'foo'); // int(-1) var_dump([] []); // int(0) var_dump([2, 4, 5] [2, 4, 5]); // int(0) var_dump([2, 4, 5] [2, 4, 4]); // int(1) var_dump([2, 4, 4] [2, 4, 5]); // int(-1) var_dump(['foo' => 'cat'] ['foo' => 'cat']); // int(0) var_dump(['foo' => 'dog'] ['foo' => 'cat']); // int(1) var_dump(['foo' => 'cat'] ['foo' => 'dog']); // int(-1) var_dump(['foo' => 'cat', 'bar' => 'dog'] ['foo' => 'cat']); // int(1) var_dump(['foo' => 'cat'] ['bar' => 'dog']); // int(1) $foo = (object)['foo' => 'cat']; $bar = (object)['foo' => 'cat']; var_dump($foo $bar); // int(0) $foo = (object)['foo' => 'dog']; $bar = (object)['foo' => 'cat']; var_dump($foo $bar); // int(1) $foo = (object)['foo' => 'cat']; $bar = (object)['foo' => 'dog']; var_dump($foo $bar); // int(-1) $foo = (object)['foo' => 'cat']; $bar = (object)['bar' => 'dog']; var_dump($foo $bar); // int(1) 另一个条件运算符是 ?: （或三元运算符）。 表达式一 ? 表达式二 : 表达式三 在表达式一求值为 true 的时候值为表达式二，在表达式一求值为 false 的时候值为表达式三。建议避免将三元运算符堆积在一起使用。当在一条语句中使用多个三元运算符时会造成 PHP 运算结果不清晰。 可以省略三元运算符中间那部分。 表达式一 ?: 表达式二 在表达式一求值为 true 时返回表达式一，否则返回表达式二。 NULL 合并操作符 ?? 返回从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL 。 "},"docs/语言参考/运算符/错误控制运算符.html":{"url":"docs/语言参考/运算符/错误控制运算符.html","title":"错误控制运算符","keywords":"","body":"错误控制运算符 PHP 支持一个错误控制运算符 @ 。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。目前的错误控制运算符 @ 甚至使导致脚本终止的严重错误的错误报告也失效。这意味着如果在某个不存在或者敲错了字母的函数调用前用了 @ 来抑制错误信息，那脚本会没有任何迹象显示原因而死在那里。 "},"docs/语言参考/运算符/执行运算符.html":{"url":"docs/语言参考/运算符/执行运算符.html","title":"执行运算符","keywords":"","body":"执行运算符 PHP 支持一个执行运算符 ` 。注意这不是单引号！ PHP 将尝试将反引号中的内容作为 Shell 命令来执行，并将其输出信息返回，即可以赋给一个变量而不是简单地丢弃到标准输出。使用执行运算符 ` 的效果与 shell_exec() 函数相同。 "},"docs/语言参考/运算符/递增递减运算符.html":{"url":"docs/语言参考/运算符/递增递减运算符.html","title":"递增递减运算符","keywords":"","body":"递增递减运算符 前递增运算符和后递增运算符对于变量而言，结果都是变量的值加一。 前递增运算符首先将变量的值加一，然后返回当前的变量。 后递增运算符首先返回当前的变量，然后将变量的值加一。 递增运算符优先级高于算数运算符和赋值运算符。 前递减运算符和后递减运算符对于变量而言，结果都是变量的值减一。 前递减运算符首先将变量的值减一，然后返回当前的变量。 后递减运算符首先返回当前的变量，然后将变量的值减一。 递减运算符优先级高于算数运算符和赋值运算符。 "},"docs/语言参考/运算符/逻辑运算符.html":{"url":"docs/语言参考/运算符/逻辑运算符.html","title":"逻辑运算符","keywords":"","body":"逻辑运算符 逻辑与运算符有两种不同的形式，逻辑与运算符 && 优先级高于赋值运算符，逻辑与运算符 and 优先级低于赋值运算符。逻辑与运算符在两个值都为 true 时返回 true 。 逻辑或运算符有两种不同的形式，逻辑或运算符 || 优先级高于赋值运算符，逻辑或运算符 or 优先级低于赋值运算符。逻辑或运算符在两个值任何一个为 true 时返回 true 。 逻辑异或运算符 xor 优先级低于赋值运算符。逻辑异或运算符 xor 当一个值为 true 另一个值为 false 时返回 true 。 逻辑非运算符 ! 当一个值为 true 时返回 false ， 当一个值为 false 时返回 true 。 "},"docs/语言参考/运算符/字符串运算符.html":{"url":"docs/语言参考/运算符/字符串运算符.html","title":"字符串运算符","keywords":"","body":"字符串运算符 连接运算符 . 返回其左右参数连接后的字符串。 连接赋值运算符 .= 将右边参数附加到左边的参数之后。 "},"docs/语言参考/运算符/数组运算符.html":{"url":"docs/语言参考/运算符/数组运算符.html","title":"数组运算符","keywords":"","body":"数组运算符 联合运算符 + 把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。 int(2) [1]=> int(4) [2]=> int(5) } $foo = ['foo' => 'cat', 'bar' => 'dog']; $bar = ['foo' => '2', 'bar' => '04', 'baz' => '05']; var_dump($foo + $bar); // array(3) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [\"baz\"]=> string(2) \"05\" } $foo = ['foo' => 'cat', 'bar' => 'dog']; $bar = ['foo' => '2', 'bar' => '04', 'baz' => '05']; var_dump($bar + $foo); // array(3) { [\"foo\"]=> string(1) \"2\" [\"bar\"]=> string(2) \"04\" [\"baz\"]=> string(2) \"05\" } 等于运算符 == 在两个数组具有相同的键值对时返回 true 。 'cat', 'bar' => 'dog']; $bar = ['cat', 'dog']; var_dump($foo == $bar); // bool(false) $foo = ['foo' => 'cat', 'bar' => 'dog']; $baz = ['foo' => 0, 'bar' => 'dog']; var_dump($foo == $baz); // bool(true) 全等运算符 === 在两个数组具有相同的键值对并且顺序和类型都相同时返回 true 。 'cat', 'bar' => 'dog']; $bar = ['foo' => 0, 'bar' => 'dog']; var_dump($foo === $bar); // bool(false) $foo = ['foo' => 'cat', 'bar' => 'dog']; $baz = ['bar' => 'dog', 'foo' => 'cat']; var_dump($foo === $baz); // bool(false) 不等运算符 != 在两个数组不具有相同的键值对时返回 true 。 'cat', 'bar' => 'dog']; $bar = ['cat', 'dog']; var_dump($foo != $bar); // bool(true) $foo = ['foo' => 'cat', 'bar' => 'dog']; $baz = ['foo' => 0, 'bar' => 'dog']; var_dump($foo != $baz); // bool(false) 不全等运算符 !== 在两个数组不具有相同的键值对或顺序和类型不相同时返回 true 。 'cat', 'bar' => 'dog']; $bar = ['foo' => 0, 'bar' => 'dog']; var_dump($foo !== $bar); // bool(true) $foo = ['foo' => 'cat', 'bar' => 'dog']; $baz = ['bar' => 'dog', 'foo' => 'cat']; var_dump($foo !== $bar); // bool(true) "},"docs/语言参考/运算符/类型运算符.html":{"url":"docs/语言参考/运算符/类型运算符.html","title":"类型运算符","keywords":"","body":"类型运算符 检测一个变量是否是某个类的实例。 检测一个变量是否不是某个类的实例。 检测一个变量是否是继承自某个父类的子类的实例。 检测一个变量是否是实现某个接口的实例。 检测一个变量是否是某个对象或字符串变量的实例。 如果被检测的变量不是对象，则并不发出任何错误信息而是返回 false 。 "},"docs/语言参考/流程控制.html":{"url":"docs/语言参考/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 if else elseif while do-while for foreach switch break continue 流程控制的替代语法 declare return require include require_once include_once goto "},"docs/语言参考/流程控制/if.html":{"url":"docs/语言参考/流程控制/if.html","title":"if","keywords":"","body":"if if 结构是很多语言包括 PHP 在内最重要的特性之一，它允许按照条件执行代码片段。 if 语句可以无限层地嵌套在其它 if 语句中，这给程序的不同部分的条件执行提供了充分的弹性。 "},"docs/语言参考/流程控制/else.html":{"url":"docs/语言参考/流程控制/else.html","title":"else","keywords":"","body":"else 经常需要在满足某个条件时执行一条语句，而在不满足该条件时执行其它语句，这正是 else 的功能。 else 延伸了 if 语句，可以在 if 语句中的表达式的值为 false 时执行语句。 "},"docs/语言参考/流程控制/elseif.html":{"url":"docs/语言参考/流程控制/elseif.html","title":"elseif","keywords":"","body":"elseif 和 else 一样， elseif 延伸了 if 语句，可以在原来的 if 表达式值为 false 时执行不同语句。但是和 else 不一样的是，它仅在 elseif 的条件表达式值为 true 时执行语句。在同一个 if 语句中可以有多个 elseif 部分，其中第一个表达式值为 true （如果有的话）的 elseif 部分将会执行。 elseif 的语句仅在之前的 if 和所有之前 elseif 的表达式值为 false ，并且当前的 elseif 表达式值为 true 时执行。 "},"docs/语言参考/流程控制/while.html":{"url":"docs/语言参考/流程控制/while.html","title":"while","keywords":"","body":"while while 语句的含意很简单，它告诉 PHP 只要 while 表达式的值为 true 就重复执行嵌套中的循环语句。表达式的值在每次开始循环时检查，所以即使这个值在循环语句中改变了，语句也不会停止执行，直到本次循环结束。有时候如果 while 表达式的值一开始就是 false ，则循环语句一次都不会执行。 "},"docs/语言参考/流程控制/do-while.html":{"url":"docs/语言参考/流程控制/do-while.html","title":"do-while","keywords":"","body":"do-while do-while 循环和 while 循环非常相似，区别在于表达式的值是在每次循环结束时检查而不是开始时。 和一般的 while 循环主要的区别是 do-while 的循环语句保证会执行一次（表达式的真值在每次循环结束后检查），然而在一般的 while 循环中就不一定了（表达式真值在循环开始时检查，如果一开始就为 false 则整个循环立即终止）。 "},"docs/语言参考/流程控制/for.html":{"url":"docs/语言参考/流程控制/for.html","title":"for","keywords":"","body":"for for 循环是 PHP 中最复杂的循环结构。第一个表达式在循环开始前无条件求值（并执行）一次。第二个表达式在每次循环开始前求值。如果值为 true ，则继续循环，执行嵌套的循环语句。如果值为 false ，则终止循环。第三个表达式在每次循环之后被求值（并执行）。 第二个表达式为空意味着将无限循环下去。 10) { break; } } 每个表达式都可以为空。 10) { break; } $i++; } 每个表达式都可以包括逗号分隔的多个表达式。第二个表达式中，所有用逗号分隔的表达式都会计算，但只取最后一个结果。 由于数组的长度始终不变，可以用一个中间变量来储存数组长度以优化而不是不停调用 count() 。 "},"docs/语言参考/流程控制/foreach.html":{"url":"docs/语言参考/流程控制/foreach.html","title":"foreach","keywords":"","body":"foreach foreach 语法结构提供了遍历数组的简单方式。 foreach 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。第一种格式遍历给定的数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。 第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 $key 。 $value) { // } 可以通过引用来修改数组的元素。 int(3) [1]=> int(5) [2]=> int(6) } 还可以通过嵌套 foreach 语法结构来遍历多维数组。 PHP 可以遍历一个数组的并且把多维数组解包到循环变量中，只需将 list() 作为值提供。 "},"docs/语言参考/流程控制/switch.html":{"url":"docs/语言参考/流程控制/switch.html","title":"switch","keywords":"","body":"switch switch 语句类似于具有同一个表达式的一系列 if 语句。很多场合下需要把同一个变量（或表达式）与很多不同的值比较，并根据它等于哪个值来执行不同的代码。这正是 switch 语句的用途。如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。 为避免错误，理解 switch 是怎样执行的非常重要。 switch 语句一行接一行地执行（实际上是语句接语句）。开始时没有代码被执行。仅当一个 case 语句中的值和 switch 表达式的值匹配时 PHP 才开始执行语句，直到 switch 的程序段结束或者遇到第一个 break 语句为止。如果不在 case 的语句段最后写上 break 的话， PHP 将继续执行下一个 case 中的语句段。 在一个 case 中的语句也可以为空，这样只不过将控制转移到了下一个 case 中的语句。 一个 case 的特例是 default 。它匹配了任何和其它 case 都不匹配的情况。 "},"docs/语言参考/流程控制/break.html":{"url":"docs/语言参考/流程控制/break.html","title":"break","keywords":"","body":"break break 在循环结构中用来结束当前循环结构的执行。它可以接受一个可选的数字参数来决定跳出几重循环。默认值是 1 ，即结束当前循环结构的执行。 break 结束当前 for 结构的执行。 break 结束当前 foreach 结构的执行。 break 结束当前 while 结构的执行。 break 结束当前 do-while 结构的执行。 break 结束当前 switch 结构的执行。 "},"docs/语言参考/流程控制/continue.html":{"url":"docs/语言参考/流程控制/continue.html","title":"continue","keywords":"","body":"continue continue 在循环结构中用来跳过本次循环中剩余的代码并在条件求值为真时开始执行下一次循环。它可以接受一个可选的数字参数来决定跳过几重循环到循环结尾。默认值是 1 ，即跳到当前循环末尾。 continue 跳过当前 for 结构的执行。 continue 跳过当前 foreach 结构的执行。 continue 跳过当前 while 结构的执行。 continue 跳过当前 do-while 结构的执行。 continue 跳过当前 switch 结构的执行。 "},"docs/语言参考/流程控制/流程控制的替代语法.html":{"url":"docs/语言参考/流程控制/流程控制的替代语法.html","title":"流程控制的替代语法","keywords":"","body":"流程控制的替代语法 PHP 提供了一些流程控制的替代语法。下面是 if 的替代语法。 替代语法同样可以用在 else 中，下面是一个包括 else 的 if 结构用替代语法格式写的例子。 替代语法同样可以用在 elseif 中，下面是一个包括 elseif 的 if 结构用替代语法格式写的例子。 while 的替代语法。 for 的替代语法。 foreach 的替代语法。 switch 的替代语法。 "},"docs/语言参考/流程控制/declare.html":{"url":"docs/语言参考/流程控制/declare.html","title":"declare","keywords":"","body":"declare Tick （时钟周期）是一个在 declare 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。 N 的值是在 declare 中用 ticks = N 来指定的。不是所有语句都可计时。通常条件表达式和参数表达式都不可计时。在每个 Tick 中出现的事件是由 register_tick_function() 来指定的。注意每个 Tick 中可以出现多个事件。 0) { $foo += 2; } // string(3) \"foo\" // string(3) \"foo\" // string(3) \"foo\" 默认情况下，如果能做到的话， PHP 将会强迫错误类型的值转为函数期望的标量类型。 例如，一个函数的一个参数期望是字符串，但传入的是整型，最终函数得到的将会是一个字符串类型的值。可以基于每一个文件开启严格模式。在严格模式中，只有一个与类型声明完全相符的变量才会被接受，否则将会抛出一个 TypeError 。 唯一的一个例外是可以将整型传给一个期望浮点数的函数。使用 declare 语句和 strict_types 声明来启用严格模式。启用严格模式同时也会影响返回值类型声明。严格类型适用于在启用严格模式的文件内的函数调用，而不是在那个文件内声明的函数。 一个没有启用严格模式的文件内调用了一个在启用严格模式的文件中定义的函数，那么将会遵循调用者的偏好（弱类型），而这个值将会被转换。 "},"docs/语言参考/流程控制/return.html":{"url":"docs/语言参考/流程控制/return.html","title":"return","keywords":"","body":"return 如果在一个函数中调用 return 语句，将立即结束此函数的执行并将它的参数作为函数的值返回。 如果在全局范围中调用，则当前脚本文件中止运行。如果当前脚本文件是被 require 的或者 include 的，则控制交回调用文件。此外，如果当前脚本是被 require 的或者 include 的，则 return 的值会被当作 require 或 include 调用的返回值。如果在主脚本文件中调用 return ，则脚本中止运行。 上例中的 example.php 文件内容： "},"docs/语言参考/流程控制/require.html":{"url":"docs/语言参考/流程控制/require.html","title":"require","keywords":"","body":"require require 语句包含并运行指定文件。被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找。如果在 include_path 下没找到该文件则 require 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 require 会发出一个致命错误。 如果定义了路径，不管是绝对路径（在 Windows 下以盘符或者 \\ 开头，在 Unix / Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）， include_path 都会被完全忽略。例如一个文件以 ../ 开头，则解析器会在当前目录的父目录下寻找该文件。 当一个文件被包含时，其中所包含的代码继承了 require 所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域。 上例中的 example.php 文件内容： 如果 require 出现于调用文件中的一个函数里，则被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样。所以它将遵循该函数的变量范围。 上例中的 example.php 文件内容： 在失败时 require 发出一个致命错误。成功的包含则返回 1 ，除非在包含文件中另外给出了返回值。 上例中的 foo.php 文件内容： 上例中的 bar.php 文件内容： "},"docs/语言参考/流程控制/include.html":{"url":"docs/语言参考/流程控制/include.html","title":"include","keywords":"","body":"include include 语句包含并运行指定文件。被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找。如果在 include_path 下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 会发出一条警告。 如果定义了路径，不管是绝对路径（在 Windows 下以盘符或者 \\ 开头，在 Unix / Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）， include_path 都会被完全忽略。例如一个文件以 ../ 开头，则解析器会在当前目录的父目录下寻找该文件。 当一个文件被包含时，其中所包含的代码继承了 include 所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域。 上例中的 example.php 文件内容： 如果 include 出现于调用文件中的一个函数里，则被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样。所以它将遵循该函数的变量范围。 上例中的 example.php 文件内容： 在失败时 include 返回 false 并且发出警告。成功的包含则返回 1 ，除非在包含文件中另外给出了返回值。 上例中的 foo.php 文件内容： 上例中的 bar.php 文件内容： "},"docs/语言参考/流程控制/require_once.html":{"url":"docs/语言参考/流程控制/require_once.html","title":"require_once","keywords":"","body":"require_once require_once 语句和 require 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 require_once 可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。 "},"docs/语言参考/流程控制/include_once.html":{"url":"docs/语言参考/流程控制/include_once.html","title":"include_once","keywords":"","body":"include_once include_once 语句和 include 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 include_once 可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。 "},"docs/语言参考/流程控制/goto.html":{"url":"docs/语言参考/流程控制/goto.html","title":"goto","keywords":"","body":"goto goto 操作符可以用来跳转到程序中的另一位置。该目标位置可以用目标名称加上冒号来标记，而跳转指令是 goto 之后接上目标位置的标记。 PHP 中的 goto 有一定限制，目标位置只能位于同一个文件和作用域，也就是说无法跳出一个函数或类方法，也无法跳入到另一个函数。也无法跳入到任何循环或者 switch 结构中。 可以跳出循环或者 switch ，通常的用法是用 goto 代替多层的 break 。 "},"docs/语言参考/函数.html":{"url":"docs/语言参考/函数.html","title":"函数","keywords":"","body":"函数 用户自定义函数 函数的参数 返回值 可变函数 匿名函数 "},"docs/语言参考/函数/用户自定义函数.html":{"url":"docs/语言参考/函数/用户自定义函数.html","title":"用户自定义函数","keywords":"","body":"用户自定义函数 任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和类定义。函数名和 PHP 中的其它标识符命名规则相同。有效的函数名以字母或下划线打头，后面跟字母，数字或下划线。 函数无需在调用之前被定义，除非函数是有条件被定义的。当一个函数是有条件被定义时，必须在调用函数之前定义。 函数中的函数。 递归函数。 "},"docs/语言参考/函数/函数的参数.html":{"url":"docs/语言参考/函数/函数的参数.html","title":"函数的参数","keywords":"","body":"函数的参数 类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误。为了指定一个类型声明，类型应该加到参数名前。这个声明可以通过将参数的默认值设为 NULL 来实现允许传递 NULL 。 类型 描述 类/接口名称 参数必须是给定的类或实现接口的实例 self 参数必须是与定义方法的类相同的实例 array 参数必须是数组 callable 参数必须是可调用类型 bool 参数必须是布尔类型 float 参数必须是浮点型 int 参数必须是整型 string 参数必须是字符串 默认情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它并不会改变函数外部的值）。 int(2) [1]=> int(4) [2]=> int(5) } 如果希望允许函数修改它的参数值，必须通过引用传递参数。 int(2) [2]=> int(5) } PHP 还允许使用数组和特殊类型 NULL 作为默认参数。默认值必须是常量表达式，不能是诸如变量，类成员，或者函数调用等。注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧。否则，函数将不会按照预期的情况工作。 基本类参数类型声明。 基本接口参数类型声明。 默认情况下，如果能做到的话， PHP 将会强迫错误类型的值转为函数期望的标量类型。 例如，一个函数的一个参数期望是字符串，但传入的是整型，最终函数得到的将会是一个字符串类型的值。可以基于每一个文件开启严格模式。在严格模式中，只有一个与类型声明完全相符的变量才会被接受，否则将会抛出一个 TypeError 。 唯一的一个例外是可以将整型传给一个期望浮点数的函数。使用 declare 语句和 strict_types 声明来启用严格模式。启用严格模式同时也会影响返回值类型声明。严格类型适用于在启用严格模式的文件内的函数调用，而不是在那个文件内声明的函数。 一个没有启用严格模式的文件内调用了一个在启用严格模式的文件中定义的函数，那么将会遵循调用者的偏好（弱类型），而这个值将会被转换。 PHP 在用户自定义函数中支持可变数量的参数列表。参数列表可能包含 ... 标记，表示该函数接受可变数量的参数。参数将作为数组传递给给定变量。 还可以使用 ... 在调用函数时将数组或 Traversable 变量或文字解压缩到参数列表中。 "},"docs/语言参考/函数/返回值.html":{"url":"docs/语言参考/函数/返回值.html","title":"返回值","keywords":"","body":"返回值 与参数类型声明类似 ，返回类型声明指定将从函数返回的值的类型。 返回类型声明可以使用相同的类型。 类型 描述 类/接口名称 返回值必须是给定的类或实现接口的实例 self 返回值必须是与定义方法的类相同的实例 array 返回值必须是数组 callable 返回值必须是可调用类型 bool 返回值必须是布尔类型 float 返回值必须是浮点型 int 返回值必须是整型 string 返回值必须是字符串 值通过使用可选的返回语句返回。可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。如果省略了 return ，则返回值为 NULL 。 返回一个数组以得到多个返回值。 从函数返回一个引用。 property; } } $foo = new Foo; $property = &$foo->method(); var_dump($property); // int(5) $foo->property = 6; var_dump($property); // int(6) 基本类返回类型声明。 基本接口返回类型声明。 严格类型也会对返回类型声明产生影响。在严格模式下，返回的值必须是指定的类型，否则将引发 TypeError 。 在默认的弱类型下，如果返回的值不是指定的类型，则它将被强制转换为正确的类型。 "},"docs/语言参考/函数/可变函数.html":{"url":"docs/语言参考/函数/可变函数.html","title":"可变函数","keywords":"","body":"可变函数 PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号， PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。 可以用可变函数的语法来调用一个对象的方法。 $method(); 也可以用可变函数的语法来调用一个对象的静态属性和静态方法。 还可以调用存储在变量中的任何可调用对象。 调用类中的 __invoke 魔术方法。 "},"docs/语言参考/函数/匿名函数.html":{"url":"docs/语言参考/函数/匿名函数.html","title":"匿名函数","keywords":"","body":"匿名函数 匿名函数，也叫闭包函数，允许临时创建一个没有指定名称的函数。最经常用作回调函数参数的值。当然，也有其它应用的情况。匿名函数目前是通过 Closure 类来实现的。 闭包函数也可以作为变量的值来使用。 PHP 会自动把此种表达式转换成内置类 Closure 的对象实例。把一个 Closure 对象赋值给一个变量的方式与普通变量赋值的语法是一样的。 闭包函数可以从父作用域中继承变量， 任何此类变量都应该用 use 语言结构传递进去。 从父作用域中继承的变量的值取决于闭包函数被定义的时候，而不是被调用的时候。 闭包函数也可以从父作用域中继承变量的引用。 在类的上下文中声明时，当前类自动绑定到它，使得在函数范围内可以使用 $this 。 method(); var_dump($method()); // object(Foo)#1 (0) { } 如果不需要当前类的自动绑定，则可以使用静态匿名函数。 method(); var_dump($method()); // PHP Fatal error: Uncaught Error: Using $this when not in object context. PHP 还支持短闭包来实现更简洁的单行书写。 strtoupper($matches[1]), 'foo'); var_dump($foo); // string(3) \"FOO\" 短闭包可以直接访问闭包函数外部的变量，所以不需要再使用 use 关键词。 strtoupper($string); var_dump($foo()); // string(3) \"FOO\" "},"docs/语言参考/类与对象.html":{"url":"docs/语言参考/类与对象.html","title":"类与对象","keywords":"","body":"类与对象 基本语法 属性 类常量 类的自动加载 构造函数和析构函数 访问控制 对象继承 范围解析操作符 Static 关键字 抽象类 对象接口 Trait 匿名类 重载 遍历对象 魔术方法 Final 关键字 对象复制 对象比较 类型约束 后期静态绑定 对象和引用 对象序列化 "},"docs/语言参考/类与对象/基本语法.html":{"url":"docs/语言参考/类与对象/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 每个类的定义都以关键字 class 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。类名可以是任何非 PHP 保留字的合法标签。一个合法类名以字母或下划线开头，后面跟着若干字母，数字或下划线。一个类可以包含有属于自己的常量，变量（属性）以及函数（方法）。 当一个方法在类定义内部被调用时，有一个可用的伪变量 $this 。 $this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。 property; } } $foo = new Foo; var_dump($foo->method()); // string(3) \"foo\" 要创建一个类的实例，必须使用 new 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且在出错时抛出了一个异常。类应在被实例化之前定义（某些情况下则必须这样）。如果在 new 之后跟着的是一个包含有类名的字符串，则该类的一个实例被创建。如果该类属于一个命名空间，则必须使用其完整名称。 在类定义内部，可以用 new self 创建新对象。 在类定义内部，可以用 new parent 创建新对象。 在类定义内部，可以用 new static 创建新对象。 当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。 可以通过一个表达式来访问新创建对象的成员。 property); // string(3) \"foo\" 类中的属性和方法存在于单独的“名称空间”中，因此可以使用具有相同名称的属性和方法。 test); // string(8) \"property\" var_dump($foo->test()); // string(6) \"method\" 调用存储在属性中的匿名函数。 property = function (): string { return 'foo'; }; } } $foo = new Foo; $method = $foo->property; var_dump($method()); // string(3) \"foo\" var_dump(($foo->property)()); // string(3) \"foo\" 一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。 PHP 不支持多重继承，一个类只能继承一个基类。被继承的方法和属性可以通过用同样的名字重新声明来覆盖。但是如果父类定义方法时使用了 final ，则该方法不可被覆盖。可以通过 parent:: 来访问被覆盖的方法或属性。当覆盖方法时，参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。 method()); // string(3) \"bar\" 关键字 class 也可用于类名的解析。使用关键字 class 可以获取一个字符串，包含了类的完全限定名称。这对使用了命名空间的类尤其有用。 "},"docs/语言参考/类与对象/属性.html":{"url":"docs/语言参考/类与对象/属性.html","title":"属性","keywords":"","body":"属性 类的变量成员叫做属性。属性声明是由关键字 public ， protected 或者 private 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。在类的成员方法里面，可以用对象运算符 $this->property 这种方式来访问非静态属性。静态属性则是用范围解析操作符 self::$property 来访问。 foo); // int(5) var_dump($foo->bar); // string(3) \"bar\" var_dump($foo->baz); // array(2) { [0]=> bool(true) [1]=> bool(false) } var_dump($foo->qux); // resource(4) of type (stream) "},"docs/语言参考/类与对象/类常量.html":{"url":"docs/语言参考/类与对象/类常量.html","title":"类常量","keywords":"","body":"类常量 可以把在当前类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用美元符号 $ 。常量的值必须是一个常数。可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self ， parent 或 static ）。 bool(true) [1]=> bool(false) } $foo = new Foo; $foo = new $foo; var_dump($foo::QUX); // resource(4) of type (stream) 类常量与常量不同的是，类常量可以被子类重写。 "},"docs/语言参考/类与对象/类的自动加载.html":{"url":"docs/语言参考/类与对象/类的自动加载.html","title":"类的自动加载","keywords":"","body":"类的自动加载 在编写面向对象程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含一个长长的列表（每个类都有一个文件）。使用 spl_autoload_register() 函数可以注册任意数量的自动加载器，当使用尚未被定义的类和接口时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 上例中的 Foo.php 文件内容： 上例中的 Bar.php 文件内容： "},"docs/语言参考/类与对象/构造函数和析构函数.html":{"url":"docs/语言参考/类与对象/构造函数和析构函数.html","title":"构造函数和析构函数","keywords":"","body":"构造函数和析构函数 PHP 允许开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 property = 'foo'; } } $foo = new Foo; var_dump($foo->property); // string(3) \"foo\" 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct() 。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。 property = 'foo'; } } class Bar { /** * Override the parent constructor. * * @param void * @return void */ public function __construct() { $this->property = 'bar'; } } class Baz extends Foo { /** * Call the parent constructor. * * @param void * @return void */ public function __construct() { parent::__construct(); } } class Qux extends Foo { // } $foo = new Foo; var_dump($foo->property); // string(3) \"foo\" $bar = new Bar; var_dump($bar->property); // string(3) \"bar\" $baz = new Baz; var_dump($baz->property); // string(3) \"foo\" $qux = new Qux; var_dump($qux->property); // string(3) \"foo\" PHP 引入了析构函数的概念，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct() 。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。析构函数即使在使用 exit() 终止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。 "},"docs/语言参考/类与对象/访问控制.html":{"url":"docs/语言参考/类与对象/访问控制.html","title":"访问控制","keywords":"","body":"访问控制 对属性或方法的访问控制，是通过在前面添加关键字 public （公有）， protected （受保护）或 private （私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。 $this->public, 'protected' => $this->protected, 'private' => $this->private ]; } } $foo = new Foo; var_dump($foo->public); // string(6) \"public\" var_dump($foo->protected); // PHP Fatal error: Uncaught Error: Cannot access protected property Foo::$protected. var_dump($foo->private); // PHP Fatal error: Uncaught Error: Cannot access private property Foo::$private. var_dump($foo->method()); // array(3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(9) \"protected\" [\"private\"]=> string(7) \"private\" } 可以对 public 属性和 protected 属性进行覆盖，但 private 属性不能。 $this->public, 'protected' => $this->protected, 'private' => $this->private ]; } } $bar = new Bar; var_dump($bar->public); // string(6) \"public\" var_dump($bar->protected); // PHP Fatal error: Uncaught Error: Cannot access protected property Bar::$protected. var_dump($bar->private); // NULL var_dump($bar->method()); // array(3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(3) \"bar\" [\"private\"]=> NULL } 类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 $this->public(), 'protected' => $this->protected(), 'private' => $this->private() ]; } } $foo = new Foo; var_dump($foo->public()); // string(6) \"public\" var_dump($foo->protected()); // PHP Fatal error: Uncaught Error: Call to protected method Foo::protected() from context ''. var_dump($foo->private()); // PHP Fatal error: Uncaught Error: Call to private method Foo::private() from context ''. var_dump($foo->method()); // array(3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(9) \"protected\" [\"private\"]=> string(7) \"private\" } 可以对 public 方法和 protected 方法进行覆盖，但 private 方法不能。 $this->public(), 'protected' => $this->protected(), 'private' => $this->private() ]; } } $bar = new Bar; var_dump($bar->public()); // string(6) \"public\" var_dump($bar->protected()); // PHP Fatal error: Uncaught Error: Call to protected method Bar::protected() from context ''. var_dump($bar->private()); // PHP Fatal error: Uncaught Error: Call to private method Foo::private() from context ''. var_dump($bar->method()); // PHP Fatal error: Uncaught Error: Call to private method Foo::private() from context 'Bar'. 更多的例子。 public()); var_dump($this->private()); } } class Bar extends Foo { /** * Override the parent method. * * @param void * @return string */ public function public(): string { return 'Bar::public'; } /** * Private method. * * @param void * @return string */ private function private(): string { return 'Bar::private'; } } $bar = new Bar; $bar->method(); // string(11) \"Bar::public\" // string(12) \"Foo::private\" 同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。 property = $value; } /** * Change the specified property of the specified class. * * @param Foo $instance * @return string */ public function method(Foo $instance): string { return $instance->property = 'bar'; } } $foo = new Foo('foo'); var_dump($foo->method(new Foo('bar'))); // string(3) \"bar\" "},"docs/语言参考/类与对象/对象继承.html":{"url":"docs/语言参考/类与对象/对象继承.html","title":"对象继承","keywords":"","body":"对象继承 PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，否则被继承的方法都会保留其原有功能。继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。 method()); // string(3) \"foo\" var_dump($foo->test()); // string(4) \"test\" $bar = new Bar; var_dump($bar->method()); // string(3) \"bar\" var_dump($bar->test()); // string(4) \"test\" "},"docs/语言参考/类与对象/范围解析操作符.html":{"url":"docs/语言参考/类与对象/范围解析操作符.html","title":"范围解析操作符","keywords":"","body":"范围解析操作符 范围解析操作符，或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。当在类定义之外引用到这些项目时，要使用类名。也可以通过变量来引用类，但该变量的值不能是关键字（如 self ， parent 和 static ）。 self ， parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的。 static()); // string(3) \"FOO\" var_dump($bar->self()); // string(3) \"BAR\" var_dump($bar->parent()); // string(3) \"FOO\" var_dump($bar->static()); // string(3) \"BAR\" 当一个子类覆盖其父类中的方法时， PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。这种机制也作用于构造函数和析构函数，重载以及魔术方法。 method()); // string(3) \"foo\" "},"docs/语言参考/类与对象/Static 关键字.html":{"url":"docs/语言参考/类与对象/Static 关键字.html","title":"Static 关键字","keywords":"","body":"Static 关键字 声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。静态属性不可以由对象运算符 -> 来访问。用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为常数。可以用一个变量来动态调用类，但该变量的值不能为关键字 self ， parent 或 static 。 调用静态方法。 "},"docs/语言参考/类与对象/抽象类.html":{"url":"docs/语言参考/类与对象/抽象类.html","title":"抽象类","keywords":"","body":"抽象类 PHP 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。继承一个抽象类的时候，子类必须定义父类中的所有抽象方法。另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。如果子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 method('bar')); // string(3) \"bar\" var_dump($bar->test()); // string(3) \"foo\" $baz = new Baz; var_dump($baz->method('baz')); // string(3) \"baz\" var_dump($baz->test()); // string(3) \"baz\" 抽象类中也可以定义常量。抽象类中的常量和类常量的使用完全相同，也可以被子类重写。 "},"docs/语言参考/类与对象/对象接口.html":{"url":"docs/语言参考/类与对象/对象接口.html","title":"对象接口","keywords":"","body":"对象接口 使用接口，可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。接口中定义的所有方法都必须是公有，这是接口的特性。要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，必须使用和接口中所定义的方法完全一致的方式，否则会报一个致命错误。 method('bar')); // string(3) \"bar\" $baz = new Baz; var_dump($baz->method('baz')); // string(3) \"baz\" 接口也可以继承，通过使用 extends 操作符。 类可以实现多个接口，用逗号来分隔多个接口的名称。实现多个接口时，接口中的方法不能有重名。 接口中也可以定义常量。接口中的常量和类常量的使用完全相同，但是不能被子类或子接口所重写。 "},"docs/语言参考/类与对象/Trait.html":{"url":"docs/语言参考/类与对象/Trait.html","title":"Trait","keywords":"","body":"Trait PHP 实现了一种代码复用的方法，称为 Trait 。 Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。 Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用方法。 Trait 和类组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。 Trait 和类相似，但仅仅旨在用细粒度和一致的方式来组合功能。无法通过 Trait 自身来实例化。它为传统继承增加了水平特性的组合，也就是说，应用的几个类之间不需要继承。 method()); // string(3) \"foo\" $baz = new Baz; var_dump($baz->method()); // string(3) \"foo\" 从基类继承的成员会被 Trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 Trait 的方法，而 Trait 则覆盖了被继承的方法。 method()); // string(3) \"bar\" $qux = new Qux; var_dump($qux->method()); // string(3) \"baz\" 通过逗号分隔，在 use 声明列出多个 Trait ，可以都插入到一个类中。 foo()); // string(3) \"foo\" var_dump($baz->bar()); // string(3) \"bar\" 如果两个 Trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。为了解决多个 Trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。以上方式仅允许排除掉其它方法， as 操作符可以 为某个方法引入别名。 注意， as 操作符不会对方法进行重命名，也不会影响其方法。 method()); // string(3) \"foo\" $qux = new Qux; var_dump($qux->method()); // string(3) \"bar\" var_dump($qux->test()); // string(3) \"bar\" 使用 as 语法还可以用来调整方法的访问控制。 method()); // string(3) \"foo\" $baz = new Baz; var_dump($baz->method()); // PHP Fatal error: Uncaught Error: Call to protected method Baz::method() from context '' var_dump($baz->test()); // string(3) \"foo\" 正如类能够使用 Trait 一样，其它 Trait 也能够使用 Trait 。在 Trait 定义时通过使用一个或多个 Trait ，能够组合其它 Trait 中的部分或全部成员。 foo()); // string(3) \"foo\" var_dump($qux->bar()); // string(3) \"bar\" 为了对使用的类施加强制要求， Trait 支持抽象方法的使用。 method()); // string(3) \"bar\" Trait 方法中的静态变量。 Trait 中的静态方法。 Trait 中同样可以定义属性。 Trait 定义了一个属性后，类就不能定义同样名称的属性，否则会产生致命错误。 有种情况例外：属性是兼容的（同样的访问可见度、初始默认值）。 "},"docs/语言参考/类与对象/匿名类.html":{"url":"docs/语言参考/类与对象/匿名类.html","title":"匿名类","keywords":"","body":"匿名类 匿名类很有用，可以创建一次性的简单对象。 string(3) \"foo\" } 可以传递参数到匿名类的构造器，也可以扩展其他类，实现接口，以及像其他普通的类一样使用 Trait 。 string(3) \"foo\" } var_dump($qux->method('qux')); // string(3) \"qux\" var_dump($qux->test()); // string(3) \"baz\" 匿名类被嵌套进普通类后，不能在匿名类中访问这个外部类的 private 、 protected 方法或者属性。为了访问外部类 protected 属性或方法，匿名类可以 extends 此外部类。 为了使用外部类的 private 属性，必须通过构造函数传进来。 bar) extends Foo { /** * Just a test property. * * @var int */ private int $baz; /** * Initialize the value of the property. * * @param int * @return void */ public function __construct(int $value) { $this->baz = $value; } /** * Calculate the sum of all expressions. * * @param void * @return int */ public function test(): int { return $this->foo + $this->baz + $this->method(); } }; } } $foo = new Foo; var_dump($foo->call()->test()); // int(6) 声明的同一个匿名类，所创建的对象都是这个类的实例。 "},"docs/语言参考/类与对象/重载.html":{"url":"docs/语言参考/类与对象/重载.html","title":"重载","keywords":"","body":"重载 PHP 所提供的重载是指动态地创建类属性和方法。是通过魔术方法来实现的。当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。所有的重载方法都必须被声明为 public 。传统的重载是用于提供多个同名的类方法，但各方法的参数类型和个数不同。 在给不可访问属性赋值时， __set() 会被调用。 $name = $value; } } $foo = new Foo; $foo->property = 'foo'; var_dump($foo->property); // string(3) \"foo\" 读取不可访问属性的值时， __get() 会被调用。 $name; } } $foo = new Foo; var_dump($foo->property); // string(3) \"foo\" 当对不可访问属性调用 isset() 或 empty() 时， __isset() 会被调用。 $name); } } $foo = new Foo; var_dump(isset($foo->property)); // bool(true) 当对不可访问属性调用 unset() 时， __unset() 会被调用。 $name); } /** * Unset the specified property. * * @param string $name * @return void */ public function __unset(string $name) { unset($this->$name); } } $foo = new Foo; var_dump(isset($foo->property)); // bool(true) unset($foo->property); var_dump(isset($foo->property)); // bool(false) 在对象中调用一个不可访问方法时， __call() 会被调用。 method('foo', 'bar')); // string(14) \"method+foo+bar\" 在静态上下文中调用一个不可访问方法时， __callStatic() 会被调用。 "},"docs/语言参考/类与对象/遍历对象.html":{"url":"docs/语言参考/类与对象/遍历对象.html","title":"遍历对象","keywords":"","body":"遍历对象 PHP 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 foreach 语句。默认情况下，所有可见属性都将被用于遍历。 $value) { var_dump(\"$key => $value\"); } } } $foo = new Foo; foreach ($foo as $key => $value) { var_dump(\"$key => $value\"); } // string(16) \"public => public\" $foo->method(); // string(16) \"public => public\" // string(22) \"protected => protected\" // string(18) \"private => private\" 更进一步，可以实现 Iterator 接口。可以让对象自行决定如何遍历以及每次遍历时那些值可用。 property = $array; } /** * Return the current element of the specified property. * * @param void * @return int */ public function current(): int { var_dump(__METHOD__); return current($this->property); } /** * Advance the internal pointer of the specified property. * * @param void * @return void */ public function next() { var_dump(__METHOD__); next($this->property); } /** * Return the current key of the specified property. * * @param void * @return int */ public function key(): int { var_dump(__METHOD__); return key($this->property); } /** * Return the validity of the current position of the specified property. * * @param void * @return bool */ public function valid(): bool { var_dump(__METHOD__); return current($this->property) !== false; } /** * Set the internal pointer of the specified property to the first element. * * @param void * @return void */ public function rewind() { var_dump(__METHOD__); reset($this->property); } } $foo = new Foo([2, 4, 5]); foreach ($foo as $key => $value) { var_dump(\"$key => $value\"); echo \"\\r\\n\"; } // string(11) \"Foo::rewind\" // string(10) \"Foo::valid\" // string(12) \"Foo::current\" // string(8) \"Foo::key\" // string(6) \"0 => 2\" // string(9) \"Foo::next\" // string(10) \"Foo::valid\" // string(12) \"Foo::current\" // string(8) \"Foo::key\" // string(6) \"1 => 4\" // string(9) \"Foo::next\" // string(10) \"Foo::valid\" // string(12) \"Foo::current\" // string(8) \"Foo::key\" // string(6) \"2 => 5\" // string(9) \"Foo::next\" // string(10) \"Foo::valid\" 可以用 IteratorAggregate 接口以替代实现所有的 Iterator 方法。 IteratorAggregate 只需要实现一个方法 getIterator() ，其应返回一个实现了 Iterator 的类的实例。 $value) { var_dump(\"$key => $value\"); } // string(10) \"foo => foo\" // string(10) \"bar => bar\" // string(10) \"baz => baz\" // string(10) \"qux => qux\" "},"docs/语言参考/类与对象/魔术方法.html":{"url":"docs/语言参考/类与对象/魔术方法.html","title":"魔术方法","keywords":"","body":"魔术方法 __construct() ， __destruct() ， __call() ， __callStatic() ， __get() ， __set() ， __isset() ， __unset() ， __sleep() ， __wakeup() ， __toString() ， __invoke() ， __set_state() ， __clone() 和 __debugInfo() 等方法在 PHP 中被称为魔术方法。 PHP 允许开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 property = 'foo'; } } $foo = new Foo; var_dump($foo->property); // string(3) \"foo\" PHP 引入了析构函数的概念，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 在对象中调用一个不可访问方法时， __call() 会被调用。 method('foo', 'bar')); // string(14) \"method+foo+bar\" 在静态上下文中调用一个不可访问方法时， __callStatic() 会被调用。 在给不可访问属性赋值时， __set() 会被调用。 $name = $value; } } $foo = new Foo; $foo->property = 'foo'; var_dump($foo->property); // string(3) \"foo\" 读取不可访问属性的值时， __get() 会被调用。 $name; } } $foo = new Foo; var_dump($foo->property); // string(3) \"foo\" 当对不可访问属性调用 isset() 或 empty() 时， __isset() 会被调用。 $name); } } $foo = new Foo; var_dump(isset($foo->property)); // bool(true) 当对不可访问属性调用 unset() 时， __unset() 会被调用。 $name); } /** * Unset the specified property. * * @param string $name * @return void */ public function __unset(string $name) { unset($this->$name); } } $foo = new Foo; var_dump(isset($foo->property)); // bool(true) unset($foo->property); var_dump(isset($foo->property)); // bool(false) serialize() 函数会检查类中是否存在一个魔术方法 __sleep() 。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 __sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 与之相反， unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup() 方法，预先准备对象需要的资源。 __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 property = 'foo'; } } $foo = 'O:3:\"Foo\":1:{s:6:\"public\";s:6:\"public\";}'; var_dump(unserialize($foo)); // object(Foo)#1 (4) { [\"public\"]=> string(6) \"public\" [\"protected\":protected]=> string(9) \"protected\" [\"private\":\"Foo\":private]=> string(7) \"private\" [\"property\"]=> string(3) \"foo\" } __toString() 方法用于一个类被当成字符串时应怎样回应。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 当尝试以调用函数的方式调用一个对象时， __invoke() 方法会被自动调用。 当调用 var_export() 函数导出类的相关信息时， __set_state() 静态方法会被调用。此方法的唯一参数是一个数组，其中包含按数组键值对格式排列的类属性。 property = $array['property']; return $object; } } $foo = new Foo; $foo->property = 'foo'; var_export($foo); // Foo::__set_state(array( 'property' => 'foo', )) $bar = Foo::__set_state(array( 'property' => 'foo', )); var_dump($bar); // object(Foo)#2 (1) { [\"property\"]=> string(3) \"foo\" } 对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。当对象被复制后， PHP 会对对象的所有属性执行一个浅复制。所有的引用属性仍然会是一个指向原来的变量的引用。当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 name = $name; $this->age = $age; } } class Dog { /** * The name of dog. * * @var string */ public string $name; /** * Store an instance of cat. * * @var Cat */ public Cat $cat; /** * Complete deep copy. * * @param void * @return void */ public function __clone() { $this->cat = clone $this->cat; } } $spike = new Dog; $spike->name = 'Spike'; $spike->cat = new Cat('Tom', 6); $tyke = clone $spike; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } $tyke->name = 'Tyke'; $tyke->cat->age = 2; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(4) \"Tyke\" [\"cat\"]=> object(Cat)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(2) } } 当调用 var_dump() 函数打印类的相关信息时， __debugInfo 方法会被调用。如果未在对象上定义该方法，则将显示所有公共属性，受保护属性和私有属性。 $this->public, 'protected' => $this->protected, 'private' => $this->private ]; } } $foo = new Foo; var_dump($foo); // object(Foo)#1 (3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(9) \"protected\" [\"private\"]=> string(7) \"private\" } "},"docs/语言参考/类与对象/Final 关键字.html":{"url":"docs/语言参考/类与对象/Final 关键字.html","title":"Final 关键字","keywords":"","body":"Final 关键字 如果一个类被声明为 final ，则不能被继承。 如果父类中的方法被声明为 final ，则子类无法覆盖该方法。 "},"docs/语言参考/类与对象/对象复制.html":{"url":"docs/语言参考/类与对象/对象复制.html","title":"对象复制","keywords":"","body":"对象复制 在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果第一个对象中保存着第二个对象的引用，当你复制第一个对象时，你想使用的对象不再是第二个对象而是它的一个副本，那么你必须得到第二个对象的一个副本。对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。当对象被复制后， PHP 会对对象的所有属性执行一个浅复制。所有的引用属性仍然会是一个指向原来的变量的引用。 name = $name; $this->age = $age; } } class Dog { /** * The name of dog. * * @var string */ public string $name; /** * Store an instance of cat. * * @var Cat */ public Cat $cat; } $spike = new Dog; $spike->name = 'Spike'; $spike->cat = new Cat('Tom', 6); $tyke = clone $spike; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } $tyke->name = 'Tyke'; $tyke->cat->age = 2; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(2) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(4) \"Tyke\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(2) } } 当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 name = $name; $this->age = $age; } } class Dog { /** * The name of dog. * * @var string */ public string $name; /** * Store an instance of cat. * * @var Cat */ public Cat $cat; /** * Complete deep copy. * * @param void * @return void */ public function __clone() { $this->cat = clone $this->cat; } } $spike = new Dog; $spike->name = 'Spike'; $spike->cat = new Cat('Tom', 6); $tyke = clone $spike; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } $tyke->name = 'Tyke'; $tyke->cat->age = 2; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(4) \"Tyke\" [\"cat\"]=> object(Cat)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(2) } } 可以将对象序列化后再反序列化来完成对象的深复制。 name = $name; $this->age = $age; } } class Dog { /** * The name of dog. * * @var string */ public string $name; /** * Store an instance of cat. * * @var Cat */ public Cat $cat; } $spike = new Dog; $spike->name = 'Spike'; $spike->cat = new Cat('Tom', 6); $tyke = unserialize(serialize($spike)); var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } $tyke->name = 'Tyke'; $tyke->cat->age = 2; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(Dog)#3 (2) { [\"name\"]=> string(4) \"Tyke\" [\"cat\"]=> object(Cat)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(2) } } 还可以将对象进行 JSON 编码后再解码来完成对象的深复制。 name = $name; $this->age = $age; } } class Dog { /** * The name of dog. * * @var string */ public string $name; /** * Store an instance of cat. * * @var Cat */ public Cat $cat; } $spike = new Dog; $spike->name = 'Spike'; $spike->cat = new Cat('Tom', 6); $tyke = json_decode(json_encode($spike)); var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(stdClass)#3 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(stdClass)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } $tyke->name = 'Tyke'; $tyke->cat->age = 2; var_dump($spike); // object(Dog)#1 (2) { [\"name\"]=> string(5) \"Spike\" [\"cat\"]=> object(Cat)#2 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(6) } } var_dump($tyke); // object(stdClass)#3 (2) { [\"name\"]=> string(4) \"Tyke\" [\"cat\"]=> object(stdClass)#4 (2) { [\"name\"]=> string(3) \"Tom\" [\"age\"]=> int(2) } } "},"docs/语言参考/类与对象/对象比较.html":{"url":"docs/语言参考/类与对象/对象比较.html","title":"对象比较","keywords":"","body":"对象比较 当使用比较运算符 == 比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。而如果使用比较运算符 === ，这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。 property = 'foo'; $bar = new Foo; $bar->property = 'bar'; var_dump($foo == $bar); // bool(false) var_dump($foo != $bar); // bool(true) var_dump($foo === $bar); // bool(false) var_dump($foo !== $bar); // bool(true) $foo = new Foo; $bar = new Bar; var_dump($foo == $bar); // bool(false) var_dump($foo != $bar); // bool(true) var_dump($foo === $bar); // bool(false) var_dump($foo !== $bar); // bool(true) $foo = new Foo; $bar = $foo; var_dump($foo == $bar); // bool(true) var_dump($foo != $bar); // bool(false) var_dump($foo === $bar); // bool(true) var_dump($foo !== $bar); // bool(false) "},"docs/语言参考/类与对象/类型约束.html":{"url":"docs/语言参考/类与对象/类型约束.html","title":"类型约束","keywords":"","body":"类型约束 PHP 可以在类中使用类型约束。参数和返回值可以指定必须为对象（在函数原型里面指定类的名字），接口，数组或者可调用类型等等。不过如果使用 NULL 作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为参数。如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。 method('foo')); // string(3) \"foo\" $bar = new Bar; var_dump($bar->method(0)); // string(1) \"0\" "},"docs/语言参考/类与对象/后期静态绑定.html":{"url":"docs/语言参考/类与对象/后期静态绑定.html","title":"后期静态绑定","keywords":"","body":"后期静态绑定 后期静态绑定的功能，用于在继承范围内引用静态调用的类。准确的说，后期静态绑定工作原理是存储了在上一个“非转发调用”的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在范围解析操作符符 :: 左侧部分）。当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”指的是通过以下几种方式进行的静态调用： self:: ， parent:: ， static:: 以及 forward_static_call() 。可以在类中用 get_called_class() 函数来得到被调用的方法所在的类名， static:: 则指出了其范围。该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说， static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于定义当前方法所在的类。 使用后期静态绑定。 在非静态环境下，所调用的类即为该对象实例所属的类。由于 $this 会在同一作用范围内尝试调用私有方法，而 static:: 则可能给出不同结果。另一个区别是 static:: 只能用于静态属性。 method()); var_dump(static::method()); } } class Bar extends Foo { // } class Baz extends Foo { /** * Override the parent method. * * @param void * @return void */ private function method() { // } } $bar = new Bar; $bar->test(); // string(7) \"success\" // string(7) \"success\" $baz = new Baz; $baz->test(); // string(7) \"success\" // PHP Fatal error: Uncaught Error: Call to private method Baz::method() from context 'Foo'. 后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 parent:: 或者 self:: 等将会转发调用。 "},"docs/语言参考/类与对象/对象和引用.html":{"url":"docs/语言参考/类与对象/对象和引用.html","title":"对象和引用","keywords":"","body":"对象和引用 在 PHP 的对象编程中经常提到的一个关键点是“默认情况下对象是通过引用传递的”。但其实这不是完全正确的。PHP 的引用是别名，就是两个不同的变量名字指向相同的内容。在 PHP 中，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。 property = 'bar'; var_dump($bar->property); // string(3) \"bar\" 标识符的拷贝和引用： string(3) \"foo\" } var_dump($baz); // NULL 当对象作为参数传递： property = 'bar'; } class Foo { /** * Just a test property. * * @var string */ public string $property = 'foo'; } $foo = new Foo; foo($foo); var_dump($foo->property); // string(3) \"bar\" "},"docs/语言参考/类与对象/对象序列化.html":{"url":"docs/语言参考/类与对象/对象序列化.html","title":"对象序列化","keywords":"","body":"对象序列化 所有 PHP 里面的值都可以使用函数 serialize() 来返回一个包含字节流的字符串来表示，而 unserialize() 函数则能够重新把字符串变回 PHP 原来的值。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。为了能够 unserialize() 一个对象，这个对象的类必须已经定义过。 上例中的 Foo.php 文件内容： property; } } 如果要想在另外一个文件中反序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数 spl_autoload_register() 来实现。 method()); // string(3) \"foo\" "},"docs/语言参考/命名空间.html":{"url":"docs/语言参考/命名空间.html","title":"命名空间","keywords":"","body":"命名空间 基本语法 定义子命名空间 在同一个文件中定义多个命名空间 使用命名空间 - 基础 命名空间和动态语言特征 namespace 关键字和 __NAMESPACE__ 魔术常量 使用命名空间 - 别名和导入 全局空间 使用命名空间 - 后备全局函数和常量 名称解析规则 "},"docs/语言参考/命名空间/基本语法.html":{"url":"docs/语言参考/命名空间/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。在 PHP 中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 用户编写的代码与 PHP 内部的类 / 函数 / 常量或第三方类 / 函数 / 常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 虽然任意合法的 PHP 代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和 Trait ）、接口、函数和常量。命名空间通过关键字 namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外： declare 关键字。 另外，与 PHP 其它的语言特征不同，同一个命名空间可以定义在多个文件中，即允许将同一个命名空间的内容分割存放在不同的文件中。 上例中的 example.php 文件内容： "},"docs/语言参考/命名空间/定义子命名空间.html":{"url":"docs/语言参考/命名空间/定义子命名空间.html","title":"定义子命名空间","keywords":"","body":"定义子命名空间 与目录和文件的关系很象， PHP 命名空间也允许指定层次化的命名空间的名称。 "},"docs/语言参考/命名空间/在同一个文件中定义多个命名空间.html":{"url":"docs/语言参考/命名空间/在同一个文件中定义多个命名空间.html","title":"在同一个文件中定义多个命名空间","keywords":"","body":"在同一个文件中定义多个命名空间 也可以在同一个文件中定义多个命名空间。 不建议使用这种语法在单个文件中定义多个命名空间。建议使用下面的大括号形式的语法。在实际的编程实践中，非常不提倡在同一个文件中定义多个命名空间。这种方式的主要用于将多个 PHP 脚本合并在同一个文件中。 将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来。 "},"docs/语言参考/命名空间/使用命名空间 - 基础.html":{"url":"docs/语言参考/命名空间/使用命名空间 - 基础.html","title":"使用命名空间 - 基础","keywords":"","body":"使用命名空间 - 基础 在讨论如何使用命名空间之前，必须了解 PHP 是如何知道要使用哪一个命名空间中的元素的。可以将 PHP 命名空间与文件系统作一个简单的类比。在文件系统中访问一个文件有三种方式： 相对文件名如 foo.txt 。它会被解析为 CurrentDirectory/foo.txt ，其中 CurrentDirectory 表示当前目录。因此如果当前目录是 /home/foo ，则该文件名被解析为 /home/foo/foo.txt 。 相对路径名如 SubDirectory/foo.txt 。它会被解析为 CurrentDirectory/SubDirectory/foo.txt 。 绝对路径名如 /main/foo.txt 。它会被解析为 /main/foo.txt 。 PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用： 非限定名称，或不包含前缀的类名称，例如 $foo = new Foo 。如果当前命名空间是 CurrentNamespace ， Foo 将被解析为 CurrentNamespace\\Foo 。如果使用 Foo 的代码是全局的，不包含在任何命名空间中的代码，则 Foo 会被解析为 Foo 。 限定名称，或包含前缀的名称，例如 $foo = new SubNamespace\\Foo 。如果当前的命名空间是 CurrentNamespace ，则 Foo 会被解析为 CurrentNamespace\\SubNamespace\\Foo 。如果使用 Foo 的代码是全局的，不包含在任何命名空间中的代码， Foo 会被解析为 SubNamespace\\Foo 。 完全限定名称，或包含了全局前缀操作符的名称，例如， $foo = new \\CurrentNamespace\\Foo 。在这种情况下， Foo 总是被解析为代码中的文字名 CurrentNamespace\\Foo 。 上例中的 example.php 文件内容： 如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。 上例中的 example.php 文件内容： "},"docs/语言参考/命名空间/命名空间和动态语言特征.html":{"url":"docs/语言参考/命名空间/命名空间和动态语言特征.html","title":"命名空间和动态语言特征","keywords":"","body":"命名空间和动态语言特征 PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码 example.php 转换到命名空间中： 必须使用完全限定名称（包括命名空间前缀的类名称）。注意因为在动态的类名称、函数名称或常量名称中，限定名称和完全限定名称没有区别，因此其前导的反斜杠是不必要的。 "},"docs/语言参考/命名空间/namespace 关键字和 __NAMESPACE__ 魔术常量.html":{"url":"docs/语言参考/命名空间/namespace 关键字和 __NAMESPACE__ 魔术常量.html","title":"namespace 关键字和 __NAMESPACE__ 魔术常量","keywords":"","body":"namespace 关键字和 __NAMESPACE__ 魔术常量 PHP 支持两种抽象的访问当前命名空间内部元素的方法， __NAMESPACE__ 魔术常量和 namespace 关键字。常量 __NAMESPACE__ 的值是包含当前命名空间名称的字符串。 在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。 常量 __NAMESPACE__ 在动态创建名称时很有用。 关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。 全局命名空间中的 namespace 操作符。 "},"docs/语言参考/命名空间/使用命名空间 - 别名和导入.html":{"url":"docs/语言参考/命名空间/使用命名空间 - 别名和导入.html","title":"使用命名空间 - 别名和导入","keywords":"","body":"使用命名空间 - 别名和导入 允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。这有点类似于在类 Unix 文件系统中可以创建对其它的文件或目录的符号连接。所有支持命名空间的 PHP 版本支持三种别名或导入方式：为类名称使用别名、为接口使用别名或为命名空间名称使用别名。也允许导入函数或常量或者为它们设置别名。在 PHP 中，别名是通过操作符 use 来实现的。 array(0) { } } var_dump(new Baz); // object(Foo\\Bar\\Baz)#1 (0) { } var_dump(new ClassBaz); // object(Foo\\Bar\\Baz)#1 (0) { } var_dump(baz()); // string(7) \"Foo\\Bar\" var_dump(FunctionBaz()); // string(7) \"Foo\\Bar\" var_dump(BAZ); // string(7) \"Foo\\Bar\" var_dump(ConstantBaz); // string(7) \"Foo\\Bar\" 上例中的 example.php 文件内容： 注意对命名空间中的名称来说，前导的反斜杠是不必要的也不推荐的，因为导入的名称必须是完全限定的，不会根据当前的命名空间作相对解析。为了简化操作， PHP 还支持在一行中使用多个 use 语句。 上例中的 example.php 文件内容： 导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。 上例中的 example.php 文件内容： 另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。 上例中的 example.php 文件内容： "},"docs/语言参考/命名空间/全局空间.html":{"url":"docs/语言参考/命名空间/全局空间.html","title":"全局空间","keywords":"","body":"全局空间 如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \\ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。 上例中的 example.php 文件内容： "},"docs/语言参考/命名空间/使用命名空间 - 后备全局函数和常量.html":{"url":"docs/语言参考/命名空间/使用命名空间 - 后备全局函数和常量.html","title":"使用命名空间 - 后备全局函数和常量","keywords":"","body":"使用命名空间 - 后备全局函数和常量 一个命名空间中，当 PHP 遇到一个非限定的类，函数或常量名称时，它使用不同的优先策略来解析该名称。类名称总是解析到当前命名空间中的名称。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称。 array(0) { } } var_dump(new \\ArrayObject); // object(ArrayObject)#1 (1) { [\"storage\":\"ArrayObject\":private]=> array(0) { } } var_dump(new stdClass); // PHP Fatal error: Uncaught Error: Class 'Foo\\stdClass' not found. 如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。 上例中的 example.php 文件内容： "},"docs/语言参考/命名空间/名称解析规则.html":{"url":"docs/语言参考/命名空间/名称解析规则.html","title":"名称解析规则","keywords":"","body":"名称解析规则 在说明名称解析规则之前，先看一些重要的定义： 非限定名称，名称中不包含命名空间分隔符的标识符，例如 Foo 。 限定名称，名称中含有命名空间分隔符的标识符，例如 Foo\\Bar 。 完全限定名称，名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \\Foo\\Bar 。 namespace\\Foo 也是一个完全限定名称。 名称解析遵循下列规则： 对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \\Foo\\Bar 解析为类 Foo\\Bar 。 所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 Foo\\Bar 被导入为 Bar ，那么对 Bar\\Baz 的调用就会被转换为 Foo\\Bar\\Baz 。 在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 Foo\\Bar 内部调用 Baz\\Qux ，则 Baz\\Qux 会被转换为 Foo\\Bar\\Baz\\Qux 。 非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 Foo\\Bar\\Baz 导入为 Baz ，则 new Baz 被转换为 new Foo\\Bar\\Baz 。 在命名空间内部（例如 Foo\\Bar ），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的： 在当前命名空间中查找名为 Foo\\Bar\\foo() 的函数。 尝试查找并调用全局空间中的函数 foo() 。 在命名空间（例如 Foo\\Bar ）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new Baz 的解析过程： 在当前命名空间中查找 Foo\\Bar\\Baz 类。 尝试自动装载类 Foo\\Bar\\Baz 。 为了引用全局命名空间中的全局类，必须使用完全限定名称。 "},"docs/语言参考/Errors.html":{"url":"docs/语言参考/Errors.html","title":"Errors","keywords":"","body":"Errors PHP 改变了大多数错误的报告方式。不同于传统的错误报告机制，现在大多数错误被作为 Error 异常抛出。这种 Error 异常可以像 Exception 异常一样被第一个匹配的 try / catch 块所捕获。如果没有匹配的 catch 块，则调用异常处理函数（事先通过 set_exception_handler() 注册）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误。 Error 类并非继承自 Exception 类，所以不能用 catch (Exception $e) { ... } 来捕获 Error 。你可以用 catch (Error $e) { ... } ，或者通过注册异常处理函数 set_exception_handler() 来捕获 Error 。 "},"docs/语言参考/异常处理.html":{"url":"docs/语言参考/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 基本语法 扩展 PHP 内置的异常处理类 "},"docs/语言参考/异常处理/基本语法.html":{"url":"docs/语言参考/异常处理/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 PHP 有一个类似于其他编程语言的异常模型。一个异常可以在 PHP 中被抛出和捕获。代码可以被包围在 try 块中，以便于捕获潜在的异常。每个 try 块中必须至少有一个相应的 catch 或 finally 块。抛出的对象必须是 Exception 类或 Exception 类的子类的一个实例。尝试抛出一个非对象将导致 PHP 致命错误。可以使用多个 catch 块来捕获不同类别的异常。正常执行（当 try 块中没有抛出异常时）将在顺序定义的最后一个 catch 块之后继续。可以在 catch 块中抛出（或重新抛出）异常。 try 中的代码一旦抛出异常，代码将停止运行，直接执行 catch 中的代码， PHP 将尝试查找第一个匹配的 catch 块。如果未捕获异常，则将发出带有 Uncaught Exception ... 消息的 PHP 致命错误，除非已使用 set_exception_handler() 函数定义了处理程序。也可以在 catch 块之后指定 finally 块。 finally 块中的代码将始终在 try 和 catch 块之后执行，无论是否抛出异常，并且在正常执行恢复之前。 getMessage()); } var_dump('baz'); // string(3) \"foo\" // string(3) \"bar\" // string(3) \"baz\" 使用 finally 块进行异常处理。 getMessage()); } finally { var_dump(false); } try { var_dump(foo(true)); } catch (Exception $e) { var_dump($e->getMessage()); } finally { var_dump(true); } var_dump('baz'); // string(3) \"foo\" // bool(false) // string(3) \"bar\" // bool(true) // string(3) \"baz\" 嵌套异常。 getMessage()); } } } $foo = new Foo; $foo->method(); // string(3) \"foo\" "},"docs/语言参考/异常处理/扩展 PHP 内置的异常处理类.html":{"url":"docs/语言参考/异常处理/扩展 PHP 内置的异常处理类.html","title":"扩展 PHP 内置的异常处理类","keywords":"","body":"扩展 PHP 内置的异常处理类 用户可以用自定义的异常处理类来扩展 PHP 内置的异常处理类。如果使用自定义的类来扩展内置异常处理类，并且要重新定义构造函数的话，建议同时调用 parent::__construct() 来检查所有的变量是否已被赋值。当对象要输出字符串的时候，可以重载 __toString() 并自定义输出的样式。 getMessage()); //string(3) \"foo\" var_dump($e->getCode()); // int(1) } "},"docs/语言参考/生成器.html":{"url":"docs/语言参考/生成器.html","title":"生成器","keywords":"","body":"生成器 生成器总览 生成器语法 生成器与 Iterator 对象比较 "},"docs/语言参考/生成器/生成器总览.html":{"url":"docs/语言参考/生成器/生成器总览.html","title":"生成器总览","keywords":"","body":"生成器总览 生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。生成器允许你在 foreach 代码块中写代码来迭代一组数据而不需要在内存中创建一个数组，那会使你的内存达到上限，或者会占据可观的处理时间。相反，你可以写一个生成器函数，就像一个普通的自定义函数一样，和普通函数只返回一次不同的是，生成器可以根据需要 yield 多次，以便生成需要迭代的值。当第一次调用生成器函数时，将返回内部 Generator 类的对象。此对象实现 Iterator 接口的方式与仅向前迭代器对象的方式非常相似，并提供可以调用以操纵生成器状态的方法，包括向其发送值和从中返回值。一个简单的例子就是使用生成器来重新实现 range() 函数。 标准的 range() 函数需要在内存中生成一个数组包含每一个在它范围内的值，然后返回该数组，结果就是会产生多个很大的数组。比如，调用 range(0, 1000000) 将导致内存占用超过 100 MB 。做为一种替代方法，可以实现一个 xrange() 生成器, 只需要足够的内存来创建 Iterator 对象并在内部跟踪生成器的当前状态，这样只需要不到 1 KB 字节的内存。 "},"docs/语言参考/生成器/生成器语法.html":{"url":"docs/语言参考/生成器/生成器语法.html","title":"生成器语法","keywords":"","body":"生成器语法 一个生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以 yield 生成许多它所需要的值。当一个生成器被调用的时候，它返回一个可以被遍历的对象。当你遍历这个对象的时候（例如通过一个 foreach 循环）， PHP 将会在每次需要值的时候调用生成器函数，并在产生一个值之后保存生成器的状态，这样它就可以在需要产生下一个值的时候恢复调用状态。一旦不再需要产生更多的值，生成器函数可以简单退出，而调用生成器的代码还可以继续执行，就像一个数组已经被遍历完了。生成器函数的核心是 yield 关键字。它最简单的调用形式看起来像一个 return 申明，不同之处在于普通 return 会返回值并终止函数的执行，而 yield 会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。 PHP 的数组支持关联键值对数组，生成器也一样支持。所以除了生成简单的值，也可以在生成值的时候指定键名。 $value; } } $foo = foo('1.foo;2.bar;3.baz;4.qux'); foreach ($foo as $key => $value) { var_dump(\"$key => $value\"); } // string(8) \"1 => foo\" // string(8) \"2 => bar\" // string(8) \"3 => baz\" // string(8) \"4 => qux\" yield 可以在没有参数传入的情况下被调用来生成一个 NULL 值并配对一个自动的键名。 NULL [1]=> NULL [2]=> NULL [3]=> NULL [4]=> NULL [5]=> NULL [6]=> NULL [7]=> NULL [8]=> NULL [9]=> NULL } 生成器函数可以像使用值一样来使用引用生成。这个和从函数返回一个引用一样，通过在函数名前面加一个引用符号。 0) { yield $foo; } } $foo = foo(); foreach ($foo as &$value) { var_dump($value--); } // int(3) // int(2) // int(1) 生成器委派允许你通过使用 yield from 来从另一个生成器， Traversable 对象或数组中生成值。 然后外部生成器将从内部生成器，对象或数组中生成所有值，直到它不再有效，之后将在外部生成器中继续执行。如果生成器与 yield from 一起使用，则表达式的 yield 也将返回内部生成器返回的任何值。 同时使用 yield 和 return 。 getReturn()); // int(1) // int(2) // int(3) // int(4) // int(5) // int(6) // int(7) // int(8) // int(9) // int(10) "},"docs/语言参考/生成器/生成器与 Iterator 对象比较.html":{"url":"docs/语言参考/生成器/生成器与 Iterator 对象比较.html","title":"生成器与 Iterator 对象比较","keywords":"","body":"生成器与 Iterator 对象比较 生成器的主要优点是简单。与实现 Iterator 类相比，编写更少的代码 ，并且代码通常更具可读性。然而，这种灵活性需要付出代价，生成器只是仅向前迭代器，一旦迭代开始就无法倒回。这也意味着同一个生成器不能多次迭代，生成器需要通过再次调用生成器函数来重建，或者通过 clone 关键字克隆。 property = fopen(__DIR__ . '/example.txt', 'r'); } /** * Return the current line content of the specified property. * * @param void * @return string */ public function current(): string { return trim($this->line); } /** * Save the next line content and line number to the specified property and advance the file pointer. * * @param void * @return void */ public function next() { if ($this->line !== false) { $this->line = fgets($this->property); $this->number++; } } /** * Return the current line number of the specified property. * * @param void * @return int */ public function key(): int { return $this->number; } /** * Return the validity of the current position of the specified property. * * @param void * @return bool */ public function valid(): bool { return $this->line !== false; } /** * Set the file pointer of the specified property to the first line and rewind the value of the specified property. * * @param void * @return void */ public function rewind() { fseek($this->property, 0); $this->line = fgets($this->property); $this->number = 0; } } $foo = foo(); foreach ($foo as $value) { var_dump($value); } // string(3) \"foo\" // string(3) \"bar\" // string(3) \"baz\" // string(3) \"qux\" foreach ($foo as $value) { var_dump($value); } // PHP Fatal error: Uncaught Exception: Cannot traverse an already closed generator. $foo = new Foo; foreach ($foo as $value) { var_dump($value); } // string(3) \"foo\" // string(3) \"bar\" // string(3) \"baz\" // string(3) \"qux\" foreach ($foo as $value) { var_dump($value); } // string(3) \"foo\" // string(3) \"bar\" // string(3) \"baz\" // string(3) \"qux\" 上例中的 example.txt 文件内容： foo bar baz qux "},"docs/语言参考/引用的解释.html":{"url":"docs/语言参考/引用的解释.html","title":"引用的解释","keywords":"","body":"引用的解释 引用是什么 引用不是什么 引用做什么 引用传递 引用返回 取消引用 引用定位 "},"docs/语言参考/引用的解释/引用是什么.html":{"url":"docs/语言参考/引用的解释/引用是什么.html","title":"引用是什么","keywords":"","body":"引用是什么 在 PHP 中引用意味着用不同的名字访问同一个变量内容。注意在 PHP 中，变量名和变量内容是不一样的，因此同样的内容可以有不同的名字。最接近的比喻是 Unix 的文件名和文件本身，变量名是目录条目，而变量内容则是文件本身。引用可以被看作是 Unix 文件系统中的硬链接。 "},"docs/语言参考/引用的解释/引用不是什么.html":{"url":"docs/语言参考/引用的解释/引用不是什么.html","title":"引用不是什么","keywords":"","body":"引用不是什么 引用不是指针。 "},"docs/语言参考/引用的解释/引用做什么.html":{"url":"docs/语言参考/引用的解释/引用做什么.html","title":"引用做什么","keywords":"","body":"引用做什么 PHP 的引用允许用两个变量来指向同一个内容。 如果对一个未定义的变量进行引用赋值，引用参数传递或引用返回，则会自动创建该变量。 NULL } $foo = new stdClass; foo($foo->foo); var_dump(property_exists($foo, 'foo')); // bool(true) 如果在一个函数内部给一个声明为 global 的变量赋予一个引用，该引用只在函数内部可见。可以通过使用 $GLOBALS 超全局数组来避免这一点。 如果在 foreach 语句中给一个具有引用的变量赋值，被引用的对象也被改变。 int(3) [1]=> int(5) [2]=> int(6) } 可以将一个变量通过引用传递给函数，这样该函数就可以修改其参数的值。 "},"docs/语言参考/引用的解释/引用传递.html":{"url":"docs/语言参考/引用的解释/引用传递.html","title":"引用传递","keywords":"","body":"引用传递 可以将一个变量通过引用传递给函数，这样该函数就可以修改其参数的值。 "},"docs/语言参考/引用的解释/引用返回.html":{"url":"docs/语言参考/引用的解释/引用返回.html","title":"引用返回","keywords":"","body":"引用返回 当想用函数找到引用应该被绑定在哪一个变量上面时可以使用引用返回。 property; } } $foo = new Foo; $property = &$foo->method(); var_dump($property); // int(5) $foo->property = 6; var_dump($property); // int(6) "},"docs/语言参考/引用的解释/取消引用.html":{"url":"docs/语言参考/引用的解释/取消引用.html","title":"取消引用","keywords":"","body":"取消引用 当 unset() 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。 "},"docs/语言参考/引用的解释/引用定位.html":{"url":"docs/语言参考/引用的解释/引用定位.html","title":"引用定位","keywords":"","body":"引用定位 许多 PHP 的语法结构是通过引用机制实现的，所以有关引用绑定的一切也都适用于这些结构。当用 global 声明一个变量时实际上建立了一个到全局变量的引用。 "},"docs/语言参考/预定义变量.html":{"url":"docs/语言参考/预定义变量.html","title":"预定义变量","keywords":"","body":"预定义变量 超全局变量 $GLOBALS $_GET $_POST $_COOKIE $_REQUEST $_FILES $_SESSION $_SERVER $_ENV $http_response_header $argc $argv "},"docs/语言参考/预定义变量/超全局变量.html":{"url":"docs/语言参考/预定义变量/超全局变量.html","title":"超全局变量","keywords":"","body":"超全局变量 超全局变量是在全部作用域中始终可用的内置变量。 PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global 就可以访问它们。这些超全局变量是： $GLOBALS 、 $_GET 、 $_POST 、 $_COOKIE 、 $_REQUEST 、 $_FILES 、 $_SESSION 、 $_SERVER 、 $_ENV 。 "},"docs/语言参考/预定义变量/$GLOBALS.html":{"url":"docs/语言参考/预定义变量/$GLOBALS.html","title":"$GLOBALS","keywords":"","body":"$GLOBALS $GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 "},"docs/语言参考/预定义变量/$_GET.html":{"url":"docs/语言参考/预定义变量/$_GET.html","title":"$_GET","keywords":"","body":"$_GET $_GET 是一个通过 URL 参数传递给当前脚本的变量的数组。 当访问 http://localhost/?foo=foo 时，以上例程的输出类似于： string(3) \"foo\" "},"docs/语言参考/预定义变量/$_POST.html":{"url":"docs/语言参考/预定义变量/$_POST.html","title":"$_POST","keywords":"","body":"$_POST 当 HTTP POST 请求的 Content-Type 是 application/x-www-form-urlencoded 或 multipart/form-data 时，会将变量以关联数组形式传入当前脚本。 假设用户通过 HTTP POST 方式传递了参数 foo=foo ，以上例程的输出类似于： string(3) \"foo\" "},"docs/语言参考/预定义变量/$_COOKIE.html":{"url":"docs/语言参考/预定义变量/$_COOKIE.html","title":"$_COOKIE","keywords":"","body":"$_COOKIE $_COOKIE 是一个通过 HTTP Cookie 方式传递给当前脚本的变量的数组。 假设之前发送了 foo=foo 的 Cookie ，以上例程的输出类似于： string(3) \"foo\" "},"docs/语言参考/预定义变量/$_REQUEST.html":{"url":"docs/语言参考/预定义变量/$_REQUEST.html","title":"$_REQUEST","keywords":"","body":"$_REQUEST $_REQUEST 是一个默认情况下包含了 $_GET ， $_POST 和 $_COOKIE 的数组。 当访问 http://localhost/?foo=foo 时，以上例程的输出类似于： string(3) \"foo\" 假设用户通过 HTTP POST 方式传递了参数 foo=foo ，以上例程的输出类似于： string(3) \"foo\" 假设之前发送了 foo=foo 的 Cookie ，以上例程的输出类似于： string(3) \"foo\" "},"docs/语言参考/预定义变量/$_FILES.html":{"url":"docs/语言参考/预定义变量/$_FILES.html","title":"$_FILES","keywords":"","body":"$_FILES $_FILES 是通过 HTTP POST 方式上传到当前脚本的项目的数组。 假设用户通过 HTTP POST 方式上传了 foo.txt 文件，以上例程的输出类似于： array(5) { [\"name\"]=> string(7) \"foo.txt\" [\"type\"]=> string(10) \"text/plain\" [\"tmp_name\"]=> string(0) \"\" [\"error\"]=> int(0) [\"size\"]=> int(0) } "},"docs/语言参考/预定义变量/$_SESSION.html":{"url":"docs/语言参考/预定义变量/$_SESSION.html","title":"$_SESSION","keywords":"","body":"$_SESSION $_SESSION 是当前脚本可用 Session 变量的数组。 假设之前保存了 foo=foo 的 Session 变量，以上例程的输出类似于： string(3) \"foo\" "},"docs/语言参考/预定义变量/$_SERVER.html":{"url":"docs/语言参考/预定义变量/$_SERVER.html","title":"$_SERVER","keywords":"","body":"$_SERVER $_SERVER 是一个包含了诸如头信息，路径，以及脚本位置等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目，服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 $_SERVER['PHP_SELF'] 是当前执行脚本的文件名，与根目录有关 。例如，在地址为 http://localhost/foo/bar.php 的脚本中使用 $_SERVER['PHP_SELF'] 将得到 /foo/bar.php 。 $_SERVER['PHP_SELF'] = $_SERVER['SCRIPT_NAME'] + $_SERVER['PATH_INFO'] $_SERVER['argv'] 是包含当运行于命令行下时传递给当前脚本的参数的数组。 $_SERVER['argc'] 是包含当运行于命令行下时传递给当前脚本的参数的数目。 $_SERVER['GATEWAY_INTERFACE'] 是服务器使用的 CGI 规范的版本。 $_SERVER['SERVER_ADDR'] 是当前运行脚本所在的服务器的 IP 地址。 $_SERVER['SERVER_NAME'] 是当前运行脚本所在的服务器的主机名。 $_SERVER['SERVER_SOFTWARE'] 是服务器标识字符串，在响应请求时的头信息中给出。 $_SERVER['SERVER_PROTOCOL'] 是请求页面时通信协议的名称和版本。 $_SERVER['REQUEST_METHOD'] 是访问页面使用的请求方法。例如， GET ， POST ， PUT ， DELETE 。 $_SERVER['REQUEST_TIME'] 是请求开始时的时间戳。 $_SERVER['REQUEST_TIME_FLOAT'] 是请求开始时的时间戳，微秒级别的精准度。 $_SERVER['QUERY_STRING'] 是页面的查询字符串，如果有的话，通过它进行页面访问。 $_SERVER['DOCUMENT_ROOT'] 是当前运行脚本所在的文档根目录。在服务器配置文件中定义。 $_SERVER['HTTP_ACCEPT'] 是当前请求头中 Accept 项的内容，如果存在的话。 $_SERVER['HTTP_ACCEPT_CHARSET'] 是当前请求头中 Accept-Charset 项的内容，如果存在的话。 $_SERVER['HTTP_ACCEPT_ENCODING'] 是当前请求头中 Accept-Encoding 项的内容，如果存在的话。 $_SERVER['HTTP_ACCEPT_LANGUAGE'] 是当前请求头中 Accept-Language 项的内容，如果存在的话。 $_SERVER['HTTP_CONNECTION'] 是当前请求头中 Connection 项的内容，如果存在的话。 $_SERVER['HTTP_HOST'] 是当前请求头中 Host 项的内容，如果存在的话。 $_SERVER['HTTP_REFERER'] 是引导用户代理到当前页的前一页的地址（如果存在）。由用户代理设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。 $_SERVER['HTTP_USER_AGENT'] 是当前请求头中 User-Agent 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。除此之外，你可以通过 get_browser() 函数来使用该值，从而定制页面输出以便适应用户代理的性能。 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。 $_SERVER['REMOTE_ADDR'] 是浏览当前页面的用户的 IP 地址。 $_SERVER['REMOTE_HOST'] 是浏览当前页面的用户的主机名。 $_SERVER['REMOTE_PORT'] 是用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER['REMOTE_USER'] 是经验证的用户。 $_SERVER['REDIRECT_REMOTE_USER'] 是验证的用户，如果请求已在内部重定向。 $_SERVER['SCRIPT_FILENAME'] 是当前执行脚本的绝对路径。 $_SERVER['SERVER_ADMIN'] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。 $_SERVER['SERVER_PORT'] 是 Web 服务器使用的端口。默认值为 80 。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 $_SERVER['SERVER_SIGNATURE'] 是包含了服务器版本和虚拟主机名的字符串。 $_SERVER['PATH_TRANSLATED'] 是当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 $_SERVER['SCRIPT_NAME'] 是包含当前脚本的路径。这在页面需要指向自己时非常有用。 $_SERVER['REQUEST_URI'] 是用来指定要访问的页面。 $_SERVER['PHP_AUTH_DIGEST'] 是当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的请求头中 Authorization 项的内容（以便作进一步的认证操作）。 $_SERVER['PHP_AUTH_USER'] 是当 PHP 运行在 Apache 或 IIS 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。 $_SERVER['PHP_AUTH_PW'] 是当 PHP 运行在 Apache 或 IIS 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。 $_SERVER['AUTH_TYPE'] 是当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。 $_SERVER['PATH_INFO'] 包含由客户端提供的，跟在真实脚本名称之后并且在查询字符串之前的路径信息，如果存在的话。例如，如果当前脚本是通过 http://localhost/index.php/foo/bar?foo=foo 被访问，那么 $_SERVER['PATH_INFO'] 将包含 /foo/bar 。 $_SERVER['ORIG_PATH_INFO'] 是在被 PHP 处理之前， $_SERVER['PATH_INFO'] 的原始版本。 "},"docs/语言参考/预定义变量/$_ENV.html":{"url":"docs/语言参考/预定义变量/$_ENV.html","title":"$_ENV","keywords":"","body":"$_ENV $_ENV 是通过环境方式传递给当前脚本的变量的数组。这些变量被从 PHP 解析器的运行环境导入到 PHP 的全局命名空间。很多是由支持 PHP 运行的 Shell 提供的，并且不同的系统很可能运行着不同种类的 Shell ，所以不可能有一份确定的列表。请查看你的 Shell 文档来获取定义的环境变量列表。其他环境变量包含了 CGI 变量，而不管 PHP 是以服务器模块还是 CGI 处理器的方式运行。 假设 PHP 解析器的运行环境导入了变量 foo=foo ，以上例程的输出类似于： string(3) \"foo\" "},"docs/语言参考/预定义变量/$http_response_header.html":{"url":"docs/语言参考/预定义变量/$http_response_header.html","title":"$http_response_header","keywords":"","body":"$http_response_header 当使用 HTTP 包装器时， $http_response_header 将会被 HTTP 响应头信息填充。与使用 get_headers() 函数类似。 "},"docs/语言参考/预定义变量/$argc.html":{"url":"docs/语言参考/预定义变量/$argc.html","title":"$argc","keywords":"","body":"$argc $argc 是包含当运行于命令行下时传递给当前脚本的参数的数目。 当执行 php index.php foo bar 这条命令时，以上例程的输出类似于： int(3) "},"docs/语言参考/预定义变量/$argv.html":{"url":"docs/语言参考/预定义变量/$argv.html","title":"$argv","keywords":"","body":"$argv $argv 是包含当运行于命令行下时传递给当前脚本的参数的数组。 当执行 php index.php foo bar 这条命令时，以上例程的输出类似于： array(3) { [0]=> string(9) \"index.php\" [1]=> string(3) \"foo\" [2]=> string(3) \"bar\" } "},"docs/语言参考/预定义异常.html":{"url":"docs/语言参考/预定义异常.html","title":"预定义异常","keywords":"","body":"预定义异常 Exception ErrorException "},"docs/语言参考/预定义异常/Exception.html":{"url":"docs/语言参考/预定义异常/Exception.html","title":"Exception","keywords":"","body":"Exception Exception 是所有异常的基类。 返回异常消息内容。 getMessage()); // string(3) \"foo\" } 返回异常链中的前一个异常。 getPrevious()); } 返回异常代码。 getCode()); // int(1) } 获取创建异常的程序文件名称。 getFile()); } 返回发生异常的代码在文件中的行号。 getLine()); // int(6) } 以数组类型返回异常追踪信息。 getTrace()); } 以字符串类型返回异常追踪信息。 getTraceAsString()); } 返回转换为字符串类型的异常。 尝试克隆异常，这将导致一个致命错误。 "},"docs/语言参考/预定义异常/ErrorException.html":{"url":"docs/语言参考/预定义异常/ErrorException.html","title":"ErrorException","keywords":"","body":"ErrorException Exception 异常构造函数。 返回异常的严重程度。 getSeverity()); // int(1) } "},"docs/语言参考/预定义接口.html":{"url":"docs/语言参考/预定义接口.html","title":"预定义接口","keywords":"","body":"预定义接口 Traversable Iterator IteratorAggregate ArrayAccess Serializable Closure Generator "},"docs/语言参考/预定义接口/Traversable.html":{"url":"docs/语言参考/预定义接口/Traversable.html","title":"Traversable","keywords":"","body":"Traversable 检测一个类是否可以使用 foreach 进行遍历的接口。无法被单独实现的基本抽象接口。相反它必须由 IteratorAggregate 或 Iterator 接口实现。 "},"docs/语言参考/预定义接口/Iterator.html":{"url":"docs/语言参考/预定义接口/Iterator.html","title":"Iterator","keywords":"","body":"Iterator 可在内部迭代自己的外部迭代器或类的接口。 property = $array; } /** * Return the current element of the specified property. * * @param void * @return int */ public function current(): int { var_dump(__METHOD__); return current($this->property); } /** * Advance the internal pointer of the specified property. * * @param void * @return void */ public function next() { var_dump(__METHOD__); next($this->property); } /** * Return the current key of the specified property. * * @param void * @return int */ public function key(): int { var_dump(__METHOD__); return key($this->property); } /** * Return the validity of the current position of the specified property. * * @param void * @return bool */ public function valid(): bool { var_dump(__METHOD__); return current($this->property) !== false; } /** * Set the internal pointer of the specified property to the first element. * * @param void * @return void */ public function rewind() { var_dump(__METHOD__); reset($this->property); } } $foo = new Foo([2, 4, 5]); foreach ($foo as $key => $value) { var_dump(\"$key => $value\"); echo \"\\r\\n\"; } // string(11) \"Foo::rewind\" // string(10) \"Foo::valid\" // string(12) \"Foo::current\" // string(8) \"Foo::key\" // string(6) \"0 => 2\" // string(9) \"Foo::next\" // string(10) \"Foo::valid\" // string(12) \"Foo::current\" // string(8) \"Foo::key\" // string(6) \"1 => 4\" // string(9) \"Foo::next\" // string(10) \"Foo::valid\" // string(12) \"Foo::current\" // string(8) \"Foo::key\" // string(6) \"2 => 5\" // string(9) \"Foo::next\" // string(10) \"Foo::valid\" "},"docs/语言参考/预定义接口/IteratorAggregate.html":{"url":"docs/语言参考/预定义接口/IteratorAggregate.html","title":"IteratorAggregate","keywords":"","body":"IteratorAggregate 创建外部迭代器的接口。 $value) { var_dump(\"$key => $value\"); } // string(10) \"foo => foo\" // string(10) \"bar => bar\" // string(10) \"baz => baz\" // string(10) \"qux => qux\" "},"docs/语言参考/预定义接口/ArrayAccess.html":{"url":"docs/语言参考/预定义接口/ArrayAccess.html","title":"ArrayAccess","keywords":"","body":"ArrayAccess 提供像访问数组一样访问对象的能力的接口。 property = $array; } /** * Return whether the specified offset of the specified property exists. * * @param int $offset * @return bool */ public function offsetExists($offset): bool { return isset($this->property[$offset]); } /** * Return the value of the specified offset of the specified property. * * @param int $offset * @return int|string|null */ public function offsetGet($offset) { return $this->property[$offset] ?? null; } /** * Set the value of the specified offset of the specified property. * * @param int $offset * @param int|string $value * @return void */ public function offsetSet($offset, $value) { if (is_null($offset)) { $this->property[] = $value; } else { $this->property[$offset] = $value; } } /** * Unset the specified offset of the specified property. * * @param int $offset * @return void */ public function offsetUnset($offset) { unset($this->property[$offset]); } } $foo = new Foo([2, 4, 5]); var_dump(isset($foo[0])); // bool(true) var_dump($foo[0]); // int(2) unset($foo[0]); var_dump(isset($foo[0])); // bool(false) $foo[0] = 'foo'; var_dump($foo[0]); // string(3) \"foo\" $foo[] = 'bar'; $foo[] = 'baz'; $foo[] = 'qux'; var_dump($foo); // object(Foo)#1 (1) { [\"property\":\"Foo\":private]=> array(6) { [1]=> int(4) [2]=> int(5) [0]=> string(3) \"foo\" [3]=> string(3) \"bar\" [4]=> string(3) \"baz\" [5]=> string(3) \"qux\" } } "},"docs/语言参考/预定义接口/Serializable.html":{"url":"docs/语言参考/预定义接口/Serializable.html","title":"Serializable","keywords":"","body":"Serializable 自定义序列化的接口。实现此接口的类将不再支持 __sleep() 和 __wakeup() 。不论何时，只要有实例需要被序列化， serialize() 方法都将被调用。它将不会调用 __destruct() 或有其他影响，除非程序化地调用此方法。当数据被反序列化时，类将被感知并且调用合适的 unserialize() 方法而不是调用 __construct() 。如果需要执行标准的构造器，你应该在这个方法中进行处理。 property = 'foo'; } /** * Return the specified property that was serialized. * * @param void * @return string */ public function serialize(): string { return serialize($this->property); } /** * Set the value of the specified property. * * @param string $data * @return void */ public function unserialize($data) { $this->property = unserialize($data); } /** * Return the specified property. * * @param void * @return string */ public function method(): string { return $this->property; } } $foo = new Foo; $data = serialize($foo); var_dump($data); // string(25) \"C:3:\"Foo\":10:{s:3:\"foo\";}\" $foo = unserialize($data); var_dump($foo->method()); // string(3) \"foo\" "},"docs/语言参考/预定义接口/Closure.html":{"url":"docs/语言参考/预定义接口/Closure.html","title":"Closure","keywords":"","body":"Closure 用于代表匿名函数的类。匿名函数会产生这个类的对象。在过去，这个类被认为是一个实现细节，但现在可以依赖它做一些事情。这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。 bindTo(new Foo); var_dump($method()); // string(3) \"foo\" /** * Return the specified property. * * @param void * @return string */ $bar = function (): string { return $this->bar; }; $method = Closure::bind($bar, new Foo); var_dump($method()); // string(3) \"bar\" $method = $bar->bindTo(new Foo); var_dump($method()); // string(3) \"bar\" /** * Return the specified property. * * @param void * @return string */ $baz = function (): string { return static::$baz; }; $method = Closure::bind($baz, new Foo, 'Foo'); var_dump($method()); // string(3) \"baz\" $method = $baz->bindTo(new Foo, 'Foo'); var_dump($method()); // string(3) \"baz\" /** * Return the specified property. * * @param void * @return string */ $qux = function (): string { return $this->qux; }; $method = Closure::bind($qux, new Foo, 'Foo'); var_dump($method()); // string(3) \"qux\" $method = $qux->bindTo(new Foo, 'Foo'); var_dump($method()); // string(3) \"qux\" /** * Return the specified property. * * @param void * @return string */ $quux = function (): int { return $this->quux += 5; }; var_dump($quux->call(new Foo)); // int(6) $quuz = Closure::fromCallable([new Foo, 'method']); var_dump($quuz()); // string(6) \"method\" "},"docs/语言参考/预定义接口/Generator.html":{"url":"docs/语言参考/预定义接口/Generator.html","title":"Generator","keywords":"","body":"Generator send('bar'); // string(3) \"bar\" $baz = baz(); $baz->rewind(); $baz->send('baz'); // string(3) \"baz\" var_dump($baz->current()); // int(1) var_dump($baz->key()); // int(1) $baz->next(); // NULL var_dump($baz->current()); // int(2) var_dump($baz->valid()); // bool(true) "},"docs/语言参考/上下文选项和参数.html":{"url":"docs/语言参考/上下文选项和参数.html","title":"上下文选项和参数","keywords":"","body":"上下文选项和参数 套接字上下文选项 HTTP 上下文选项 FTP 上下文选项 SSL 上下文选项 CURL 上下文选项 Phar 上下文选项 MongoDB 上下文选项 Context 参数 "},"docs/语言参考/上下文选项和参数/套接字上下文选项.html":{"url":"docs/语言参考/上下文选项和参数/套接字上下文选项.html","title":"套接字上下文选项","keywords":"","body":"套接字上下文选项 "},"docs/语言参考/上下文选项和参数/HTTP 上下文选项.html":{"url":"docs/语言参考/上下文选项和参数/HTTP 上下文选项.html","title":"HTTP 上下文选项","keywords":"","body":"HTTP 上下文选项 "},"docs/语言参考/上下文选项和参数/FTP 上下文选项.html":{"url":"docs/语言参考/上下文选项和参数/FTP 上下文选项.html","title":"FTP 上下文选项","keywords":"","body":"FTP 上下文选项 "},"docs/语言参考/上下文选项和参数/SSL 上下文选项.html":{"url":"docs/语言参考/上下文选项和参数/SSL 上下文选项.html","title":"SSL 上下文选项","keywords":"","body":"SSL 上下文选项 "},"docs/语言参考/上下文选项和参数/CURL 上下文选项.html":{"url":"docs/语言参考/上下文选项和参数/CURL 上下文选项.html","title":"CURL 上下文选项","keywords":"","body":"CURL 上下文选项 "},"docs/语言参考/上下文选项和参数/Phar 上下文选项.html":{"url":"docs/语言参考/上下文选项和参数/Phar 上下文选项.html","title":"Phar 上下文选项","keywords":"","body":"Phar 上下文选项 "},"docs/语言参考/上下文选项和参数/MongoDB 上下文选项.html":{"url":"docs/语言参考/上下文选项和参数/MongoDB 上下文选项.html","title":"MongoDB 上下文选项","keywords":"","body":"MongoDB 上下文选项 "},"docs/语言参考/上下文选项和参数/Context 参数.html":{"url":"docs/语言参考/上下文选项和参数/Context 参数.html","title":"Context 参数","keywords":"","body":"Context 参数 "},"docs/语言参考/支持的协议和封装协议.html":{"url":"docs/语言参考/支持的协议和封装协议.html","title":"支持的协议和封装协议","keywords":"","body":"支持的协议和封装协议 file:// http:// ftp:// php:// zlib:// data:// global:// phar:// ssh2:// rar:// ogg:// expect:// "},"docs/语言参考/支持的协议和封装协议/file.html":{"url":"docs/语言参考/支持的协议和封装协议/file.html","title":"file://","keywords":"","body":"file:// 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。 当指定了一个相对路径（不以 / 、 \\ 、 \\\\ 或 Windows 盘符开头的路径），提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 fopen() 函数和 file_get_contents() 函数， include_path 会可选地搜索，也作为相对的路径。 属性 支持 受 allow_url_fopen 影响 No 允许读取 Yes 允许写入 Yes 允许添加 Yes 允许同时读和写 Yes 支持 stat() Yes 支持 unlink() Yes 支持 rename() Yes 支持 mkdir() Yes 支持 rmdir() Yes "},"docs/语言参考/支持的协议和封装协议/http.html":{"url":"docs/语言参考/支持的协议和封装协议/http.html","title":"http://","keywords":"","body":"http:// 允许通过 HTTP 的 GET 方法，以只读访问文件或资源。 HTTP 请求会附带一个 Host 头，用于兼容基于域名的虚拟主机。 如果在 php.ini 文件中或字节流上下文配置了 user_agent 字符串，它也会被包含在请求之中。数据流允许读取资源的 body ，而 headers 则储存在了 $http_response_header 变量里。 属性 支持 受 allow_url_fopen 限制 Yes 允许读取 Yes 允许写入 No 允许添加 No 允许同时读和写 N/A 支持 stat() No 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No "},"docs/语言参考/支持的协议和封装协议/ftp.html":{"url":"docs/语言参考/支持的协议和封装协议/ftp.html","title":"ftp://","keywords":"","body":"ftp:// 允许通过 FTP 读取存在的文件，以及创建新文件。如果服务器不支持被动模式的 FTP ，连接会失败。打开文件后既可以读也可以写，但是不能同时进行。当远程文件已经存在于 FTP 服务器上，如果尝试打开并写入文件的时候，未指定上下文选项 overwrite ，连接会失败，如果要通过 FTP 覆盖存在的文件，需要指定上下文的 overwrite 选项。 属性 支持 受 allow_url_fopen 限制 Yes 允许读取 Yes 允许写入 Yes 允许添加 Yes 允许同时读和写 No 支持 stat() Yes 支持 unlink() Yes 支持 rename() Yes 支持 mkdir() Yes 支持 rmdir() Yes "},"docs/语言参考/支持的协议和封装协议/php.html":{"url":"docs/语言参考/支持的协议和封装协议/php.html","title":"php://","keywords":"","body":"php:// php://stdin php://stdout php://stderr php://input php://output php://fd php://memory php://temp php://filter 属性 支持 受 allow_url_fopen 限制 No 受 allow_url_include 限制 php://inputphp://stdinphp://memoryphp://temp 允许读取 php://stdinphp://inputphp://fdphp://memoryphp://temp 允许写入 php://stdoutphp://stderrphp://outputphp://fdphp://memoryphp://temp 允许添加 php://stdoutphp://stderrphp://outputphp://fdphp://memoryphp://temp 允许同时读和写 php://fdphp://memoryphp://temp 支持 stat() php://memoryphp://temp 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No 仅仅支持 stream_select() php://stdinphp://stdoutphp://stderrphp://fdphp://temp php://stdin php://stdout php://stderr php://stdin 、 php://stdout 和 php://stderr 允许直接访问 PHP 进程相应的输入或者输出流。数据流引用了复制的文件描述符，所以如果打开 php://stdin 并在之后关了它，仅是关闭了复制品，真正被引用的 STDIN 并不受影响。 php://stdin 是只读的， php://stdout 和 php://stderr 是只写的。 php://input php://input 是个可以访问请求的原始数据的只读流。 php://output php://output 是一个只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。 php://fd php://fd 允许直接访问指定的文件描述符，例如 php://fd/3 引用了文件描述符 3 。 php://memory php://temp php://memory 和 php://temp 是一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后存入临时文件中。 php://filter php://filter 是一种元封装器，用于数据流打开时的筛选过滤应用。 "},"docs/语言参考/支持的协议和封装协议/zlib.html":{"url":"docs/语言参考/支持的协议和封装协议/zlib.html","title":"zlib://","keywords":"","body":"zlib:// 属性 支持 受 allow_url_fopen 限制 No 允许读取 Yes 允许写入 Yes 允许添加 Yes 允许同时读和写 No 支持 stat() No 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No "},"docs/语言参考/支持的协议和封装协议/data.html":{"url":"docs/语言参考/支持的协议和封装协议/data.html","title":"data://","keywords":"","body":"data:// 属性 支持 受 allow_url_fopen 限制 No 受 allow_url_include 限制 Yes 允许读取 Yes 允许写入 No 允许添加 No 允许同时读和写 No 支持 stat() No 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No "},"docs/语言参考/支持的协议和封装协议/global.html":{"url":"docs/语言参考/支持的协议和封装协议/global.html","title":"global://","keywords":"","body":"global:// 属性 支持 受 allow_url_fopen 限制 No 受 allow_url_include 限制 No 允许读取 No 允许写入 No 允许添加 No 允许同时读和写 No 支持 stat() No 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No getFilename(), $file->getSize()); } "},"docs/语言参考/支持的协议和封装协议/phar.html":{"url":"docs/语言参考/支持的协议和封装协议/phar.html","title":"phar://","keywords":"","body":"phar:// 属性 支持 受 allow_url_fopen 限制 No 受 allow_url_include 限制 No 允许读取 Yes 允许写入 Yes 允许添加 No 允许同时读和写 Yes 支持 stat() Yes 支持 unlink() Yes 支持 rename() Yes 支持 mkdir() Yes 支持 rmdir() Yes "},"docs/语言参考/支持的协议和封装协议/ssh2.html":{"url":"docs/语言参考/支持的协议和封装协议/ssh2.html","title":"ssh2://","keywords":"","body":"ssh2:// 属性 ssh2.shell ssh2.exec ssh2.tunnel ssh2.sftp ssh2.scp 受 allow_url_fopen 限制 Yes Yes Yes Yes Yes 允许读取 Yes Yes Yes Yes Yes 允许写入 Yes Yes Yes Yes No 允许添加 No No No Yes No 允许同时读和写 Yes Yes Yes Yes No 支持 stat() No No No Yes No 支持 unlink() No No No Yes No 支持 rename() No No No Yes No 支持 mkdir() No No No Yes No 支持 rmdir() No No No Yes No "},"docs/语言参考/支持的协议和封装协议/rar.html":{"url":"docs/语言参考/支持的协议和封装协议/rar.html","title":"rar://","keywords":"","body":"rar:// 属性 支持 受 allow_url_fopen 限制 No 受 allow_url_include 限制 No 允许读取 Yes 允许写入 No 允许添加 No 允许同时读和写 No 支持 stat() Yes 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No "},"docs/语言参考/支持的协议和封装协议/ogg.html":{"url":"docs/语言参考/支持的协议和封装协议/ogg.html","title":"ogg://","keywords":"","body":"ogg:// 通过 ogg:// 封装协议读取的文件，是作为 OGG / Vorbis 格式的压缩音频编码，同样，通过 ogg:// 封装协议写入或追加的数据格式也是压缩音频。 属性 支持 受 allow_url_fopen 限制 No 允许读取 Yes 允许写入 Yes 允许添加 Yes 允许同时读和写 No 支持 stat() No 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No "},"docs/语言参考/支持的协议和封装协议/expect.html":{"url":"docs/语言参考/支持的协议和封装协议/expect.html","title":"expect://","keywords":"","body":"expect:// 由 expect:// 封装协议打开的数据流 PTY 提供了对进程 stdio 、 stdout 和 stderr 的访问。 属性 支持 受 allow_url_fopen 限制 No 允许读取 Yes 允许写入 Yes 允许添加 Yes 允许同时读和写 No 支持 stat() No 支持 unlink() No 支持 rename() No 支持 mkdir() No 支持 rmdir() No "},"docs/函数参考.html":{"url":"docs/函数参考.html","title":"函数参考","keywords":"","body":"函数参考 "},"docs/函数参考/影响 PHP 行为的扩展.html":{"url":"docs/函数参考/影响 PHP 行为的扩展.html","title":"影响 PHP 行为的扩展","keywords":"","body":"影响 PHP 行为的扩展 "},"docs/函数参考/影响 PHP 行为的扩展/错误处理和日志记录.html":{"url":"docs/函数参考/影响 PHP 行为的扩展/错误处理和日志记录.html","title":"错误处理和日志记录","keywords":"","body":"错误处理和日志记录 debug_backtrace - 产生一条回溯跟踪 debug_print_backtrace - 打印一条回溯 error_clear_last - 清除最近一次错误 error_get_last - 获取最后发生的错误 error_log - 发送错误信息到某个地方 error_reporting - 设置应该报告何种 PHP 错误 restore_error_handler - 还原之前的错误处理函数 restore_exception_handler - 恢复之前定义过的异常处理函数 set_error_handler - 设置用户自定义的错误处理函数 set_exception_handler - 设置用户自定义的异常处理函数 trigger_error - 产生一个用户级别的 error / warning / notice 信息 user_error - 产生一个用户级别的 error / warning / notice 信息 debug_backtrace debug_print_backtrace error_clear_last error_get_last error_log error_reporting restore_error_handler restore_exception_handler set_error_handler set_exception_handler getMessage()); } set_exception_handler('foo'); throw new Exception('Uncaught Exception!'); // string(19) \"Uncaught Exception!\" trigger_error user_error "},"docs/函数参考/影响 PHP 行为的扩展/输出缓冲控制.html":{"url":"docs/函数参考/影响 PHP 行为的扩展/输出缓冲控制.html","title":"输出缓冲控制","keywords":"","body":"输出缓冲控制 flush ob_clean ob_end_clean ob_end_flush ob_flush ob_get_clean ob_get_contents ob_get_flush ob_get_length ob_get_level ob_get_status ob_gzhandler ob_implicit_flush ob_list_handlers ob_start output_add_rewrite_var output_reset_rewrite_vars "},"docs/函数参考/影响 PHP 行为的扩展/PHP 选项和信息.html":{"url":"docs/函数参考/影响 PHP 行为的扩展/PHP 选项和信息.html","title":"PHP 选项和信息","keywords":"","body":"PHP 选项和信息 assert_options - 设置 / 获取断言的各种标志 assert - 检查一个断言是否为 false cli_get_process_title - 返回当前进程的标题 cli_set_process_title - 设置进程标题 extension_loaded - 检查一个扩展是否已经加载 gc_collect_cycles - 强制收集所有现存的垃圾循环周期 gc_disable - 停用垃圾收集器 gc_enable - 激活垃圾收集器 gc_enabled - 返回垃圾收集器的状态 gc_mem_caches - 回收 Zend Engine 内存管理器使用的内存 gc_status - 获取有关垃圾收集器的信息 get_cfg_var - 获取 PHP 配置选项的值 get_current_user - 获取当前 PHP 脚本所有者名称 get_defined_constants - 返回所有常量的关联数组，键是常量名，值是常量值 get_extension_funcs - 返回模块函数名称的数组 get_include_path - 获取当前的 include_path 配置选项 get_included_files - 返回被 include 和 require 文件名的数组 get_loaded_extensions - 返回所有编译并加载模块名的数组 get_required_files - 返回被 include 和 require 文件名的数组 get_resources - 返回活动的资源 getenv - 获取一个环境变量的值 getlastmod - 获取页面最后修改的时间 getmygid - 获取当前 PHP 脚本拥有者的 GID getmyinode - 获取当前脚本的索引节点 getmypid - 获取 PHP 进程的 ID getmyuid - 获取 PHP 脚本所有者的 UID getopt - 从命令行参数列表中获取选项 getrusage - 获取当前资源使用状况 ini_alter - 为一个配置选项设置值 ini_get_all - 获取所有配置选项 ini_get - 获取一个配置选项的值 ini_restore - 恢复配置选项的值 ini_set - 为一个配置选项设置值 memory_get_peak_usage - 返回分配给 PHP 内存的峰值 memory_get_usage - 返回分配给 PHP 的内存量 php_ini_loaded_file - 取得已加载的 php.ini 文件的路径 php_ini_scanned_files - 返回从额外 ini 目录里解析的 .ini 文件列表 php_sapi_name - 返回 Web 服务器和 PHP 之间的接口类型 php_uname - 返回运行 PHP 的系统的有关信息 phpcredits - 打印 PHP 贡献者名单 phpinfo - 输出关于 PHP 配置的信息 phpversion - 获取当前的 PHP 版本 putenv - 设置环境变量的值 set_include_path - 设置 include_path 配置选项 set_time_limit - 设置脚本最大执行时间 sys_get_temp_dir - 返回用于临时文件的目录 version_compare - 对比两个 PHP 规范化的版本数字字符串 zend_thread_id - 返回当前线程的唯一识别符 zend_version - 获取当前 Zend 引擎的版本 assert_options assert cli_get_process_title cli_set_process_title extension_loaded gc_collect_cycles gc_disable gc_enable gc_enabled gc_mem_caches gc_status get_cfg_var get_current_user get_defined_constants get_extension_funcs get_include_path get_included_files get_loaded_extensions get_required_files get_resources getenv getlastmod getmygid getmyinode getmypid getmyuid getopt php example.php -a foo -b bar 当执行上面的命令时，会输出下面的结果： array(2) { [\"a\"]=> string(3) \"foo\" [\"b\"]=> string(3) \"bar\" } 上例中的 example.php 文件内容： php example.php -a foo -b bar --baz baz --qux qux 当执行上面的命令时，会输出下面的结果： array(4) { [\"a\"]=> string(3) \"foo\" [\"b\"]=> string(3) \"bar\" [\"baz\"]=> string(3) \"baz\" [\"qux\"]=> string(3) \"qux\" } 上例中的 example.php 文件内容： getrusage ini_alter ini_get_all ini_get ini_restore ini_set memory_get_peak_usage memory_get_usage php_ini_loaded_file php_ini_scanned_files php_sapi_name php_uname phpcredits phpinfo phpversion putenv set_include_path set_time_limit sys_get_temp_dir version_compare ')); // bool(true) var_dump(version_compare('7.4.0', '7.4.1', ' zend_thread_id zend_version "},"docs/函数参考/加密扩展.html":{"url":"docs/函数参考/加密扩展.html","title":"加密扩展","keywords":"","body":"加密扩展 "},"docs/函数参考/加密扩展/Hash.html":{"url":"docs/函数参考/加密扩展/Hash.html","title":"Hash","keywords":"","body":"Hash "},"docs/函数参考/加密扩展/Mcrypt.html":{"url":"docs/函数参考/加密扩展/Mcrypt.html","title":"Mcrypt","keywords":"","body":"Mcrypt "},"docs/函数参考/加密扩展/OpenSSL.html":{"url":"docs/函数参考/加密扩展/OpenSSL.html","title":"OpenSSL","keywords":"","body":"OpenSSL "},"docs/函数参考/加密扩展/密码散列算法.html":{"url":"docs/函数参考/加密扩展/密码散列算法.html","title":"密码散列算法","keywords":"","body":"密码散列算法 password_get_info - 返回指定散列的相关信息 password_hash - 创建密码的散列 password_needs_rehash - 检测散列值是否匹配指定的选项 password_verify - 验证密码是否和散列值匹配 password_get_info password_hash 12])); var_dump(password_hash('password', PASSWORD_ARGON2I)); password_needs_rehash 12])); var_dump(password_needs_rehash('$argon2i$v=19$m=65536,t=4,p=1$dGlUUTZ5Sndpb05GVDRUZg$ZYowa5FSPxSlZJaiRoc09gGZCnHCETtxCvCbv567Pbc', PASSWORD_ARGON2I)); password_verify "},"docs/函数参考/数据库扩展.html":{"url":"docs/函数参考/数据库扩展.html","title":"数据库扩展","keywords":"","body":"数据库扩展 "},"docs/函数参考/数据库扩展/数据库抽象层.html":{"url":"docs/函数参考/数据库扩展/数据库抽象层.html","title":"数据库抽象层","keywords":"","body":"数据库抽象层 "},"docs/函数参考/数据库扩展/数据库抽象层/PDO.html":{"url":"docs/函数参考/数据库扩展/数据库抽象层/PDO.html","title":"PDO","keywords":"","body":"PDO "},"docs/函数参考/日期与时间相关扩展.html":{"url":"docs/函数参考/日期与时间相关扩展.html","title":"日期与时间相关扩展","keywords":"","body":"日期与时间相关扩展 "},"docs/函数参考/日期与时间相关扩展/日期与时间.html":{"url":"docs/函数参考/日期与时间相关扩展/日期与时间.html","title":"日期与时间","keywords":"","body":"日期与时间 "},"docs/函数参考/文件系统相关扩展.html":{"url":"docs/函数参考/文件系统相关扩展.html","title":"文件系统相关扩展","keywords":"","body":"文件系统相关扩展 目录 文件系统 "},"docs/函数参考/文件系统相关扩展/目录.html":{"url":"docs/函数参考/文件系统相关扩展/目录.html","title":"目录","keywords":"","body":"目录 chdir - 改变目录 closedir - 关闭目录句柄 dir - 返回一个 Directory 类实例 getcwd - 取得当前工作目录 opendir - 打开目录句柄 readdir - 从目录句柄中读取条目 rewinddir - 倒回目录句柄 scandir - 列出指定路径中的文件和目录 chdir closedir dir getcwd opendir readdir rewinddir scandir "},"docs/函数参考/文件系统相关扩展/文件系统.html":{"url":"docs/函数参考/文件系统相关扩展/文件系统.html","title":"文件系统","keywords":"","body":"文件系统 basename - 返回路径中的文件名部分 chgrp - 改变文件所属的组 chmod - 改变文件模式 chown - 改变文件的所有者 clearstatcache - 清除文件状态缓存 copy - 拷贝文件 dirname - 返回路径中的目录部分 disk_free_space - 返回目录中的可用空间 disk_total_space - 返回一个目录的磁盘总大小 diskfreespace - 返回目录中的可用空间 fclose - 关闭一个已打开的文件指针 feof - 测试文件指针是否到了文件结束的位置 fflush - 将缓冲内容输出到文件 fgetc - 从文件指针中读取字符 fgetcsv - 从文件指针中读入一行并解析 CSV 字段 fgets - 从文件指针中读取一行 file_exists - 检查文件或目录是否存在 file_get_contents - 将整个文件读入一个字符串 file_put_contents - 将一个字符串写入文件 file - 把整个文件读入一个数组中 fileatime - 取得文件的上次访问时间 filectime - 取得文件的 inode 修改时间 filegroup - 取得文件的组 fileinode - 取得文件的 inode filemtime - 取得文件修改时间 fileowner - 取得文件的所有者 fileperms - 取得文件的权限 filesize - 取得文件大小 filetype - 取得文件类型 flock - 轻便的咨询文件锁定 fnmatch - 用模式匹配文件名 fopen - 打开文件或者 URL fpassthru - 输出文件指针处的所有剩余数据 fputcsv - 将行格式化为 CSV 并写入文件指针 fputs - 写入文件（可安全用于二进制文件） fread - 读取文件（可安全用于二进制文件） fscanf - 从文件中格式化输入 fseek - 在文件指针中定位 fstat - 通过已打开的文件指针取得文件信息 ftell - 返回文件指针读 / 写的位置 ftruncate - 将文件截断到给定的长度 fwrite - 写入文件（可安全用于二进制文件） glob - 寻找与模式匹配的文件路径 is_dir - 判断给定文件名是否是一个目录 is_executable - 判断给定文件名是否可执行 is_file - 判断给定文件名是否为一个正常的文件 is_link - 判断给定文件名是否为一个符号连接 is_readable - 判断给定文件名是否可读 is_uploaded_file - 判断文件是否是通过 HTTP POST 上传的 is_writable - 判断给定的文件名是否可写 is_writeable - 判断给定的文件名是否可写 lchgrp - 修改符号链接的所有组 lchown - 修改符号链接的所有者 link - 建立一个硬连接 linkinfo - 获取一个连接的信息 lstat - 给出一个文件或符号连接的信息 mkdir - 新建目录 move_uploaded_file - 将上传的文件移动到新位置 parse_ini_file - 解析一个配置文件 parse_ini_string - 解析配置字符串 pathinfo - 返回文件路径的信息 pclose - 关闭进程文件指针 popen - 打开进程文件指针 readfile - 输出文件 readlink - 返回符号连接指向的目标 realpath_cache_get - 获取真实目录缓存的详情 realpath_cache_size - 获取真实路径缓冲区的大小 realpath - 返回规范化的绝对路径名 rename - 重命名一个文件或目录 rewind - 倒回文件指针的位置 rmdir - 删除目录 set_file_buffer - 设置给定流上的写文件缓冲 stat - 给出文件的信息 symlink - 建立符号连接 tempnam - 建立一个具有唯一文件名的文件 tmpfile - 建立一个临时文件 touch - 设定文件的访问和修改时间 umask - 改变当前的 umask unlink - 删除文件 basename chgrp chmod chown clearstatcache copy dirname disk_free_space disk_total_space diskfreespace fclose feof fflush fgetc 上例中的 example.txt 文件内容： 000 fgetcsv string(3) \"foo\" [1]=> string(3) \"bar\" } // array(2) { [0]=> string(3) \"baz\" [1]=> string(3) \"qux\" } rewind($handle); while (($data = fgetcsv($handle, 1024, ',')) !== false) { var_dump($data); } // array(2) { [0]=> string(3) \"foo\" [1]=> string(3) \"bar\" } // array(2) { [0]=> string(3) \"baz\" [1]=> string(3) \"qux\" } 上例中的 example.csv 文件内容： foo,bar baz,qux fgets 上例中的 example.txt 文件内容： foo bar file_exists file_get_contents file_put_contents file string(5) \"foo \" [1]=> string(5) \"bar \" [2]=> string(5) \"baz \" [3]=> string(3) \"qux\" } var_dump(file(__DIR__ . '/example.txt', FILE_USE_INCLUDE_PATH)); // array(4) { [0]=> string(5) \"foo \" [1]=> string(5) \"bar \" [2]=> string(5) \"baz \" [3]=> string(3) \"qux\" } var_dump(file(__DIR__ . '/example.txt', FILE_IGNORE_NEW_LINES)); // array(4) { [0]=> string(3) \"foo\" [1]=> string(3) \"bar\" [2]=> string(3) \"baz\" [3]=> string(3) \"qux\" } var_dump(file(__DIR__ . '/example.txt', FILE_SKIP_EMPTY_LINES)); // array(4) { [0]=> string(5) \"foo \" [1]=> string(5) \"bar \" [2]=> string(5) \"baz \" [3]=> string(3) \"qux\" } 上例中的 example.txt 文件内容： foo bar baz qux fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype flock fnmatch readfile 上例中的 example.txt 文件内容： foo bar baz qux readlink realpath_cache_get realpath_cache_size realpath rename rewind rmdir set_file_buffer stat symlink tempnam tmpfile touch umask unlink "},"docs/函数参考/国际化与字符编码支持.html":{"url":"docs/函数参考/国际化与字符编码支持.html","title":"国际化与字符编码支持","keywords":"","body":"国际化与字符编码支持 "},"docs/函数参考/国际化与字符编码支持/iconv.html":{"url":"docs/函数参考/国际化与字符编码支持/iconv.html","title":"iconv","keywords":"","body":"iconv "},"docs/函数参考/国际化与字符编码支持/多字节字符串.html":{"url":"docs/函数参考/国际化与字符编码支持/多字节字符串.html","title":"多字节字符串","keywords":"","body":"多字节字符串 "},"docs/函数参考/图像生成和处理.html":{"url":"docs/函数参考/图像生成和处理.html","title":"图像生成和处理","keywords":"","body":"图像生成和处理 "},"docs/函数参考/图像生成和处理/GD.html":{"url":"docs/函数参考/图像生成和处理/GD.html","title":"GD","keywords":"","body":"GD "},"docs/函数参考/邮件相关扩展.html":{"url":"docs/函数参考/邮件相关扩展.html","title":"邮件相关扩展","keywords":"","body":"邮件相关扩展 邮件 "},"docs/函数参考/邮件相关扩展/邮件.html":{"url":"docs/函数参考/邮件相关扩展/邮件.html","title":"邮件","keywords":"","body":"邮件 mail - 发送邮件 mail "},"docs/函数参考/数学扩展.html":{"url":"docs/函数参考/数学扩展.html","title":"数学扩展","keywords":"","body":"数学扩展 任意精度数学 数学 "},"docs/函数参考/数学扩展/任意精度数学.html":{"url":"docs/函数参考/数学扩展/任意精度数学.html","title":"任意精度数学","keywords":"","body":"任意精度数学 bcadd - 两个任意精度数字的加法计算 bccomp - 比较两个任意精度的数字 bcdiv - 两个任意精度的数字除法计算 bcmod - 对一个任意精度数字取模 bcmul - 两个任意精度数字乘法计算 bcpow - 任意精度数字的乘方 bcpowmod - 将任意精度数先进行乘方运算，然后进行取模运算 bcscale - 设置所有任意精度数学函数的默认小数点保留位数 bcsqrt - 任意精度数字的平方根 bcsub - 两个任意精度数字的减法 bcadd bccomp bcdiv bcmod bcmul bcpow bcpowmod bcscale bcsqrt bcsub "},"docs/函数参考/数学扩展/数学.html":{"url":"docs/函数参考/数学扩展/数学.html","title":"数学","keywords":"","body":"数学 abs - 绝对值 acos - 反余弦 acosh - 反双曲余弦 asin - 反正弦 asinh - 反双曲正弦 atan2 - 两个参数的反正切 atan - 反正切 atanh - 反双曲正切 base_convert - 在任意进制之间转换数字 bindec - 二进制转换为十进制 ceil - 向上取整 cos - 余弦 cosh - 双曲余弦 decbin - 十进制转换为二进制 dechex - 十进制转换为十六进制 decoct - 十进制转换为八进制 deg2rad - 将角度转换为弧度 exp - 计算 e 的指数 expm1 - 返回 exp(number) - 1 ，甚至当 number 的值接近零也能计算出准确结果 floor - 向下取整 fmod - 返回除法的浮点数余数 getrandmax - 获取随机数最大的可能值 hexdec - 十六进制转换为十进制 hypot - 计算直角三角形的斜边长度 intdiv - 对除法结果取整 is_finite - 判断是否为有限值 is_infinite - 判断是否为无限值 is_nan - 判断是否为合法数值 lcg_value - 组合线性同余发生器 log10 - 以 10 为底的对数 log1p - 返回 log(1 + number) ，甚至当 number 的值接近零也能计算出准确结果 log - 自然对数 max - 找出最大值 min - 找出最小值 mt_getrandmax - 获取随机数最大的可能值 mt_rand - 生成更好的随机数 mt_srand - 播下一个更好的随机数发生器种子 octdec - 八进制转换为十进制 pi - 获取圆周率值 pow - 指数表达式 rad2deg - 将弧度转换为角度 rand - 产生一个随机整数 round - 对浮点数进行四舍五入 sin - 正弦 sinh - 双曲正弦 sqrt - 平方根 srand - 播下随机数发生器种子 tan - 正切 tanh - 双曲正切 abs acos acosh asin asinh atan2 atan atanh base_convert bindec ceil cos cosh decbin dechex decoct deg2rad exp expm1 floor fmod getrandmax hexdec hypot intdiv is_finite is_infinite is_nan lcg_value log10 log1p log max int(2) [1]=> int(5) [2]=> int(7) } var_dump(max([2, 2, 2], [1, 1, 1, 1])); // array(4) { [0]=> int(1) [1]=> int(1) [2]=> int(1) [3]=> int(1) } var_dump(max('hello', [2, 5, 7], 42)); // array(3) { [0]=> int(2) [1]=> int(5) [2]=> int(7) } min int(2) [1]=> int(4) [2]=> int(8) } var_dump(min([2, 2, 2], [2, 1, 1, 1])); // array(3) { [0]=> int(2) [1]=> int(2) [2]=> int(2) } var_dump(min('hello', [2, 5, 7], 42)); // string(5) \"hello\" mt_getrandmax mt_rand mt_srand octdec pi pow rad2deg rand round sin sinh sqrt srand tan tanh "},"docs/函数参考/进程控制扩展.html":{"url":"docs/函数参考/进程控制扩展.html","title":"进程控制扩展","keywords":"","body":"进程控制扩展 "},"docs/函数参考/进程控制扩展/程序执行.html":{"url":"docs/函数参考/进程控制扩展/程序执行.html","title":"程序执行","keywords":"","body":"程序执行 "},"docs/函数参考/其他基本扩展.html":{"url":"docs/函数参考/其他基本扩展.html","title":"其他基本扩展","keywords":"","body":"其他基本扩展 "},"docs/函数参考/其他基本扩展/JSON.html":{"url":"docs/函数参考/其他基本扩展/JSON.html","title":"JSON","keywords":"","body":"JSON json_decode - 对 JSON 格式的字符串进行解码 json_encode - 对变量进行 JSON 编码 json_last_error_msg - 返回最后一个 json_decode() 或 json_encode() 调用的错误字符串 json_last_error - 返回最后发生的错误 json_decode int(2) [\"bar\"]=> int(5) } var_dump(json_decode('{\"foo\":2,\"bar\":5}', true)); // array(2) { [\"foo\"]=> int(2) [\"bar\"]=> int(5) } json_encode 2, 'bar' => 5])); // string(17) \"{\"foo\":2,\"bar\":5}\" json_last_error_msg json_last_error "},"docs/函数参考/其他基本扩展/杂项.html":{"url":"docs/函数参考/其他基本扩展/杂项.html","title":"杂项","keywords":"","body":"杂项 connection_aborted - 检查客户端是否已经断开 connection_status - 返回连接的状态位 constant - 返回一个常量的值 define - 定义一个常量 defined - 检查某个名称的常量是否存在 die - 输出一个消息并且退出当前脚本 eval - 把字符串作为代码执行 exit - 输出一个消息并且退出当前脚本 get_browser - 获取浏览器具有的功能 __halt_compiler - 中断编译器的执行 highlight_file - 语法高亮一个文件 highlight_string - 语法高亮字符串 hrtime - 获取系统的高分辨率时间 ignore_user_abort - 设置客户端断开连接时是否中断脚本的执行 pack - 将数据打包成二进制字符串 php_strip_whitespace - 返回删除注释和空格后的 PHP 源码 show_source - 语法高亮一个文件 sleep - 延缓执行 sys_getloadavg - 获取系统的负载 time_nanosleep - 延缓执行若干秒和纳秒 time_sleep_until - 使脚本延缓到指定的时间为止 uniqid - 生成一个唯一 ID unpack - 从二进制字符串中解压缩数据 usleep - 以指定的微秒数延迟执行 connection_aborted connection_status constant define defined die eval exit get_browser __halt_compiler highlight_file 上例中的 example.php 文件内容： highlight_string ', false); $foo = highlight_string('', true); var_dump($foo); hrtime ignore_user_abort pack php_strip_whitespace 上例中的 example.php 文件内容： show_source 上例中的 example.php 文件内容： sleep sys_getloadavg time_nanosleep time_sleep_until uniqid unpack int(80) [2]=> int(72) [3]=> int(80) } usleep "},"docs/函数参考/其他基本扩展/PHP 标准库.html":{"url":"docs/函数参考/其他基本扩展/PHP 标准库.html","title":"PHP 标准库","keywords":"","body":"PHP 标准库 "},"docs/函数参考/其他基本扩展/Streams.html":{"url":"docs/函数参考/其他基本扩展/Streams.html","title":"Streams","keywords":"","body":"Streams "},"docs/函数参考/其他基本扩展/Tokenizer.html":{"url":"docs/函数参考/其他基本扩展/Tokenizer.html","title":"Tokenizer","keywords":"","body":"Tokenizer token_get_all - 将提供的源码按 PHP 标记进行分割 token_name - 获取提供的 PHP 解析器代号的符号名称 token_get_all ')); token_name "},"docs/函数参考/其他基本扩展/URL.html":{"url":"docs/函数参考/其他基本扩展/URL.html","title":"URL","keywords":"","body":"URL base64_decode - 对使用 MIME base64 编码的数据进行解码 base64_encode - 使用 MIME base64 对数据进行编码 get_headers - 取得服务器响应一个 HTTP 请求所发送的所有报头 get_meta_tags - 从一个文件中提取所有的 meta 标签 content 属性，返回一个数组 http_build_query - 生成 URL-encode 之后的请求字符串 parse_url - 解析 URL ，返回其组成部分 rawurldecode - 对已编码的 URL 字符串进行解码 rawurlencode - 按照 RFC 3986 对 URL 进行编码 urldecode - 对已编码的 URL 字符串进行解码 urlencode - 编码 URL 字符串 base64_decode base64_encode get_headers get_meta_tags 上例中的 example.html 文件内容： http_build_query 'cat', 'bar' => 'dog'])); // string(15) \"foo=cat&bar=dog\" var_dump(http_build_query(['foo' => 'cat', 'bar' => ['dog']])); // string(22) \"foo=cat&bar%5B0%5D=dog\" var_dump(http_build_query(['foo', 'bar'], 'prefix_')); // string(25) \"prefix_0=foo&prefix_1=bar\" var_dump(http_build_query(['foo', 'bar'], 'prefix_', '&amp;')); // string(29) \"prefix_0=foo&amp;prefix_1=bar\" var_dump(http_build_query(['foo' => 'cat dog'], 'prefix_', '&amp;', PHP_QUERY_RFC1738)); // string(11) \"foo=cat+dog\" var_dump(http_build_query(['foo' => 'cat dog'], 'prefix_', '&amp;', PHP_QUERY_RFC3986)); // string(13) \"foo=cat%20dog\" parse_url string(4) \"http\" [\"host\"]=> string(8) \"hostname\" [\"port\"]=> int(80) [\"user\"]=> string(8) \"username\" [\"pass\"]=> string(8) \"password\" [\"path\"]=> string(5) \"/path\" [\"query\"]=> string(9) \"arg=value\" [\"fragment\"]=> string(6) \"anchor\" } var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_SCHEME)); // string(4) \"http\" var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_HOST)); // string(8) \"hostname\" var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_PORT)); // int(80) var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_USER)); // string(8) \"username\" var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_PASS)); // string(8) \"password\" var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_PATH)); // string(5) \"/path\" var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_QUERY)); // string(9) \"arg=value\" var_dump(parse_url('http://username:password@hostname:80/path?arg=value#anchor', PHP_URL_FRAGMENT)); // string(6) \"anchor\" rawurldecode rawurlencode urldecode urlencode "},"docs/函数参考/其他服务.html":{"url":"docs/函数参考/其他服务.html","title":"其他服务","keywords":"","body":"其他服务 "},"docs/函数参考/其他服务/CURL.html":{"url":"docs/函数参考/其他服务/CURL.html","title":"CURL","keywords":"","body":"CURL "},"docs/函数参考/其他服务/网络.html":{"url":"docs/函数参考/其他服务/网络.html","title":"网络","keywords":"","body":"网络 "},"docs/函数参考/其他服务/Sockets.html":{"url":"docs/函数参考/其他服务/Sockets.html","title":"Sockets","keywords":"","body":"Sockets "},"docs/函数参考/Session 扩展.html":{"url":"docs/函数参考/Session 扩展.html","title":"Session 扩展","keywords":"","body":"Session 扩展 Session "},"docs/函数参考/Session 扩展/Session.html":{"url":"docs/函数参考/Session 扩展/Session.html","title":"Session","keywords":"","body":"Session session_abort — 放弃会话数组的修改并结束会话 session_cache_expire — 返回当前缓存的到期时间 session_cache_limiter — 读取 / 设置缓存限制器 session_commit — 写入会话数据并结束会话 session_create_id — 创建新的会话 ID session_decode — 解码会话数据 session_destroy — 销毁一个会话中的全部数据 session_encode — 将当前会话数据编码为一个字符串 session_gc — 执行会话数据垃圾回收 session_get_cookie_params — 获取会话 Cookie 参数 session_id — 获取 / 设置当前会话 ID session_module_name — 获取 / 设置会话模块名称 session_name — 读取 / 设置会话名称 session_regenerate_id — 使用新生成的会话 ID 更新现有会话 ID session_register_shutdown — 关闭会话 session_reset — 使用原始值重新初始化会话数组 session_save_path — 读取 / 设置当前会话的保存路径 session_set_cookie_params — 设置会话 Cookie 参数 session_set_save_handler — 设置用户自定义会话存储函数 session_start — 启动新会话或者重用现有会话 session_status — 返回当前会话状态 session_unset — 释放所有的会话变量 session_write_close — 写入会话数据并结束会话 session_abort session_cache_expire session_cache_limiter session_commit session_create_id session_decode session_destory session_encode session_gc session_get_cookie_params session_id session_module_name session_name session_regenerate_id session_register_shutdown session_reset session_save_path session_set_cookie_params session_set_save_handler session_start session_status session_unset session_write_close "},"docs/函数参考/文本处理.html":{"url":"docs/函数参考/文本处理.html","title":"文本处理","keywords":"","body":"文本处理 "},"docs/函数参考/文本处理/正则表达式.html":{"url":"docs/函数参考/文本处理/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 "},"docs/函数参考/文本处理/字符串.html":{"url":"docs/函数参考/文本处理/字符串.html","title":"字符串","keywords":"","body":"字符串 "},"docs/函数参考/变量与类型相关扩展.html":{"url":"docs/函数参考/变量与类型相关扩展.html","title":"变量与类型相关扩展","keywords":"","body":"变量与类型相关扩展 数组 类与对象 字符类型检测 过滤器 函数处理 反射 变量 "},"docs/函数参考/变量与类型相关扩展/数组.html":{"url":"docs/函数参考/变量与类型相关扩展/数组.html","title":"数组","keywords":"","body":"数组 array_change_key_case - 将数组中的所有键名修改为全大写或全小写 array_chunk - 将一个数组分割成多个 array_column - 返回数组中指定的一列 array_combine - 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值 array_count_values - 统计数组中所有的值 array_diff_assoc - 带索引检查来计算数组的差集 array_diff_key - 对键名比较来计算数组的差集 array_diff_uassoc - 使用用户提供的回调函数做索引检查来计算数组的差集 array_diff_ukey - 使用用户提供的回调函数对键名比较来计算数组的差集 array_diff - 计算数组的差集 array_fill_keys - 使用指定的键和值填充数组 array_fill - 用给定的值填充数组 array_filter - 用回调函数过滤数组中的单元 array_flip - 交换数组中的键和值 array_intersect_assoc - 带索引检查来计算数组的交集 array_intersect_key - 对键名比较来计算数组的交集 array_intersect_uassoc - 使用用户提供的回调函数做索引检查来计算数组的交集 array_intersect_ukey - 使用用户提供的回调函数对键名比较来计算数组的交集 array_intersect - 计算数组的交集 array_key_exists - 检查数组里是否有指定的键名或索引 array_key_first - 获取数组的第一个键 array_key_last - 获取数组的最后一个键 array_keys - 返回数组中部分的或所有的键名 array_map - 为数组的每个元素应用回调函数 array_merge_recursive - 递归地合并一个或多个数组 array_merge - 合并一个或多个数组 array_multisort - 对多个数组或多维数组进行排序 array_pad - 以指定长度将一个值填充进数组 array_pop - 弹出数组最后一个单元（出栈） array_product - 计算数组中所有值的乘积 array_push - 将一个或多个单元压入数组的末尾（入栈） array_rand - 从数组中随机取出一个或多个单元 array_reduce - 用回调函数迭代地将数组简化为单一的值 array_replace_recursive - 使用传递的数组递归地替换第一个数组的元素 array_replace - 使用传递的数组替换第一个数组的元素 array_reverse - 返回单元顺序相反的数组 array_search - 在数组中搜索给定的值，如果成功则返回首个相应的键名 array_shift - 将数组开头的单元移出数组 array_slice - 从数组中取出一段 array_splice - 去掉数组中的某一部分并用其它值取代 array_sum - 对数组中所有值求和 array_udiff_assoc - 带索引检查来计算数组的差集，使用用户提供的回调函数比较数据 array_udiff_uassoc - 带索引检查来计算数组的差集，使用用户提供的回调函数比较数据和索引 array_udiff - 使用用户提供的回调函数来计算数组的差集 array_uintersect_assoc - 带索引检查来计算数组的交集，使用用户提供的回调函数比较数据 array_uintersect_uassoc - 带索引检查来计算数组的交集，使用用户提供的回调函数比较数据和索引 array_uintersect - 使用用户提供的回调函数来计算数组的交集 array_unique - 移除数组中重复的值 array_unshift - 在数组开头插入一个或多个单元 array_values - 返回数组中所有的值 array_walk_recursive - 使用用户自定义函数对数组中的每个元素递归地做回调处理 array_walk - 使用用户自定义函数对数组中的每个元素做回调处理 array - 新建一个数组 arsort - 对数组中的值进行逆向排序并保持索引关联 asort - 对数组中的值进行排序并保持索引关联 compact - 创建一个包含变量名和它们的值的数组 count - 计算数组中的单元数目，或对象中的属性个数 current - 返回数组中的当前单元 end - 将数组的内部指针指向最后一个单元 extract - 从数组中将变量导入到当前的符号表 in_array - 检查数组中是否存在某个值 key_exists - 检查数组里是否有指定的键名或索引 key - 从数组中取得键名 krsort - 对数组中的键名进行逆向排序 ksort - 对数组中的键名进行排序 list - 把数组中的值赋给一组变量 natcasesort - 用“自然排序”算法对数组中的值进行不区分大小写字母的排序并保持索引关联 natsort - 用“自然排序”算法对数组中的值进行排序并保持索引关联 next - 将数组中的内部指针向前移动一位 pos - 返回数组中的当前单元 prev - 将数组的内部指针倒回一位 range - 根据范围创建数组，包含指定的元素 reset - 将数组的内部指针指向第一个单元 rsort - 对数组中的值进行逆向排序 shuffle - 打乱数组 sizeof - 计算数组中的单元数目，或对象中的属性个数 sort - 对数组中的值进行排序 uasort - 使用用户自定义函数对数组中的值进行排序并保持索引关联 uksort - 使用用户自定义函数对数组中的键名进行排序 usort - 使用用户自定义函数对数组中的值进行排序 array_change_key_case int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_change_key_case(['foo' => 'cat', 'bar' => 'dog'])); // array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } var_dump(array_change_key_case(['foo' => 'cat', 'bar' => 'dog'], CASE_LOWER)); // array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } var_dump(array_change_key_case(['foo' => 'cat', 'bar' => 'dog'], CASE_UPPER)); // array(2) { [\"FOO\"]=> string(3) \"cat\" [\"BAR\"]=> string(3) \"dog\" } var_dump(array_change_key_case(['foo' => 'cat', 'FOO' => 'dog'], CASE_LOWER)); // array(1) { [\"foo\"]=> string(3) \"dog\" } var_dump(array_change_key_case(['foo' => 'cat', 'FOO' => 'dog'], CASE_UPPER)); // array(1) { [\"FOO\"]=> string(3) \"dog\" } array_chunk array(2) { [0]=> int(2) [1]=> int(4) } [1]=> array(1) { [0]=> int(5) } } var_dump(array_chunk(['foo' => 'cat', 'bar' => 'dog'], 1)); // array(2) { [0]=> array(1) { [0]=> string(3) \"cat\" } [1]=> array(1) { [0]=> string(3) \"dog\" } } var_dump(array_chunk(['foo' => 'cat', 'bar' => 'dog'], 1, true)); // array(2) { [0]=> array(1) { [\"foo\"]=> string(3) \"cat\" } [1]=> array(1) { [\"bar\"]=> string(3) \"dog\" } } array_column int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_column([['id' => 2135, 'name' => 'cat'], ['id' => 3245, 'name' => 'dog']], 'name')); // array(2) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" } var_dump(array_column([['id' => 2135, 'name' => 'cat'], ['id' => 3245, 'name' => 'dog']], 'name', 'id')); // array(2) { [2135]=> string(3) \"cat\" [3245]=> string(3) \"dog\" } var_dump(array_column([['id' => 2135, 'name' => 'cat'], ['id' => 3245, 'name' => 'dog']], null)); // array(2) { [0]=> array(2) { [\"id\"]=> int(2135) [\"name\"]=> string(3) \"cat\" } [1]=> array(2) { [\"id\"]=> int(3245) [\"name\"]=> string(3) \"dog\" } } var_dump(array_column([['id' => 2135, 'name' => 'cat'], ['id' => 3245, 'name' => 'dog']], null, 'id')); // array(2) { [2135]=> array(2) { [\"id\"]=> int(2135) [\"name\"]=> string(3) \"cat\" } [3245]=> array(2) { [\"id\"]=> int(3245) [\"name\"]=> string(3) \"dog\" } } array_combine int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_combine([0, 0, 0], [2, 4, 5])); // array(1) { [0]=> int(5) } var_dump(array_combine(['foo', 'bar'], ['cat', 'dog'])); // array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } var_dump(array_combine(['foo', 'bar'], [['cat'], ['dog']])); // array(2) { [\"foo\"]=> array(1) { [0]=> string(3) \"cat\" } [\"bar\"]=> array(1) { [0]=> string(3) \"dog\" } } array_count_values int(1) [\"bar\"]=> int(1) } var_dump(array_count_values(['foo', 'bar', 'FOO', 'BAR'])); // array(4) { [\"foo\"]=> int(1) [\"bar\"]=> int(1) [\"FOO\"]=> int(1) [\"BAR\"]=> int(1) } var_dump(array_count_values([0, 1, 2, '2'])); // array(3) { [0]=> int(1) [1]=> int(1) [2]=> int(2) } array_diff_assoc int(4) [2]=> int(5) } var_dump(array_diff_assoc([2, 4, 5], ['2', '04', '05'])); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_diff_assoc(['foo' => 'cat'], ['bar' => 'dog'])); // array(1) { [\"foo\"]=> string(3) \"cat\" } var_dump(array_diff_assoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'])); // array(0) { } array_diff_key int(4) [2]=> int(5) } var_dump(array_diff_key([2, 4, 5], ['0' => 'cat', 'bar' => 'dog'])); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_diff_key(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'], ['foo' => 0, 'bar' => 1])); // array(1) { [\"baz\"]=> string(4) \"bird\" } var_dump(array_diff_key(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'])); // array(0) { } array_diff_uassoc $b) ? 1 : -1; } var_dump(array_diff_uassoc([2, 4, 5], [2, 4, 5], 'foo')); // array(0) { } var_dump(array_diff_uassoc([2, 4, 5], [2], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_diff_uassoc([2, 4, 5], ['0' => '2', 'bar' => 'dog'], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_diff_uassoc(['foo' => 'cat'], ['bar' => 'dog'], 'foo')); // array(1) { [\"foo\"]=> string(3) \"cat\" } var_dump(array_diff_uassoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_diff_ukey $b) ? 1 : -1; } var_dump(array_diff_ukey([2, 4, 5], [2, 4, 5], 'foo')); // array(0) { } var_dump(array_diff_ukey([2, 4, 5], [2], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_diff_ukey([2, 4, 5], ['0' => 'cat', 'bar' => 'dog'], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_diff_ukey(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'], ['foo' => 0, 'bar' => 1], 'foo')); // array(1) { [\"baz\"]=> string(4) \"bird\" } var_dump(array_diff_ukey(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_diff int(4) [2]=> int(5) } var_dump(array_diff([2, 4, 5, 2], [0, 1, 2])); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_diff([2, 4, 5], [0], [2])); // array(2) { [1]=> int(4) [2]=> int(5) } array_fill_keys int(0) [4]=> int(0) [5]=> int(0) } var_dump(array_fill_keys(['foo', 'bar', 'baz'], 'cat')); // array(3) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"cat\" [\"baz\"]=> string(3) \"cat\" } var_dump(array_fill_keys(['foo', 'bar', 'baz'], ['cat', 'dog', 'bird'])); // array(3) { [\"foo\"]=> array(3) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" [2]=> string(4) \"bird\" } [\"bar\"]=> array(3) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" [2]=> string(4) \"bird\" } [\"baz\"]=> array(3) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" [2]=> string(4) \"bird\" } } array_fill int(0) [1]=> int(0) [2]=> int(0) } var_dump(array_fill(2, 3, 0)); // array(3) { [2]=> int(0) [3]=> int(0) [4]=> int(0) } var_dump(array_fill(-2, 3, 0)); // array(3) { [-2]=> int(0) [0]=> int(0) [1]=> int(0) } var_dump(array_fill(0, 3, array_fill(0, 3, 0))); // array(3) { [0]=> array(3) { [0]=> int(0) [1]=> int(0) [2]=> int(0) } [1]=> array(3) { [0]=> int(0) [1]=> int(0) [2]=> int(0) } [2]=> array(3) { [0]=> int(0) [1]=> int(0) [2]=> int(0) } } array_filter int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_filter(['foo', 0, 0.0, '0', '', []])); // array(1) { [0]=> string(3) \"foo\" } var_dump(array_filter([2, 4, 5], 'foo')); // array(1) { [2]=> int(5) } var_dump(array_filter([2, 4, 5], 'bar')); // array(2) { [0]=> int(2) [1]=> int(4) } var_dump(array_filter([2, 4, 5], 'foo', ARRAY_FILTER_USE_KEY)); // array(1) { [1]=> int(4) } var_dump(array_filter([2, 4, 5], 'bar', ARRAY_FILTER_USE_KEY)); // array(2) { [0]=> int(2) [2]=> int(5) } var_dump(array_filter([2, 4, 5], 'baz', ARRAY_FILTER_USE_BOTH)); // array(1) { [0]=> int(2) } array_flip int(0) [4]=> int(1) [5]=> int(2) } var_dump(array_flip(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'])); // array(3) { [\"cat\"]=> string(3) \"foo\" [\"dog\"]=> string(3) \"bar\" [\"bird\"]=> string(3) \"baz\" } var_dump(array_flip([2, 4, 5, '2', '4', '5'])); // array(3) { [2]=> int(3) [4]=> int(4) [5]=> int(5) } array_intersect_assoc int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_intersect_assoc([2, 4, 5], [2])); // array(1) { [0]=> int(2) } var_dump(array_intersect_assoc([2, 4, 5], ['2', '04', '05'])); // array(1) { [0]=> int(2) } var_dump(array_intersect_assoc(['foo' => 'cat'], ['bar' => 'dog'])); // array(0) { } var_dump(array_intersect_assoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'])); // array(0) { } array_intersect_key int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_intersect_key([2, 4, 5], [2])); // array(1) { [0]=> int(2) } var_dump(array_intersect_key([2, 4, 5], ['0' => 'cat', 'bar' => 'dog'])); // array(1) { [0]=> int(2) } var_dump(array_intersect_key(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'], ['foo' => 0, 'bar' => 1])); // array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } var_dump(array_intersect_key(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'])); // array(0) { } array_intersect_uassoc $b) ? 1 : -1; } var_dump(array_intersect_uassoc([2, 4, 5], [2, 4, 5], 'foo')); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_intersect_uassoc([2, 4, 5], [2], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_intersect_uassoc([2, 4, 5], ['0' => '2', 'bar' => 'dog'], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_intersect_uassoc(['foo' => 'cat'], ['bar' => 'dog'], 'foo')); // array(0) { } var_dump(array_intersect_uassoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_intersect_ukey $b) ? 1 : -1; } var_dump(array_intersect_ukey([2, 4, 5], [2, 4, 5], 'foo')); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_intersect_ukey([2, 4, 5], [2], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_intersect_ukey([2, 4, 5], ['0' => 'cat', 'bar' => 'dog'], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_intersect_ukey(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'], ['foo' => 0, 'bar' => 1], 'foo')); // array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } var_dump(array_intersect_ukey(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_intersect int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_intersect([2, 4, 5], ['2'])); // array(1) { [0]=> int(2) } var_dump(array_intersect([2, 4, 5, 2], [0, 1, 2])); // array(2) { [0]=> int(2) [3]=> int(2) } var_dump(array_intersect([2, 4, 5], [0], [2])); // array(0) { } array_key_exists 'cat', 'bar' => 'dog'])); // bool(true) array_key_first 'cat', 'bar' => 'dog'])); // string(3) \"foo\" array_key_last 'cat', 'bar' => 'dog'])); // string(3) \"bar\" array_keys int(0) [1]=> int(1) [2]=> int(2) } var_dump(array_keys(['foo' => 'cat', 'bar' => 'dog'])); // array(2) { [0]=> string(3) \"foo\" [1]=> string(3) \"bar\" } var_dump(array_keys([2, 4, 5], '5')); // array(1) { [0]=> int(2) } var_dump(array_keys([2, 4, 5], '5', true)); // array(0) { } array_map int(8) [1]=> int(64) [2]=> int(125) } var_dump(array_map('bar', [2, 4, 5], [2, 4, 5])); // array(3) { [0]=> int(4) [1]=> int(8) [2]=> int(10) } var_dump(array_map(null, ['foo' => 'cat'])); // array(1) { [\"foo\"]=> string(3) \"cat\" } var_dump(array_map(null, [0], ['foo' => 'cat'], [1, 2])); // array(2) { [0]=> array(3) { [0]=> int(0) [1]=> string(3) \"cat\" [2]=> int(1) } [1]=> array(3) { [0]=> NULL [1]=> NULL [2]=> int(2) } } var_dump(array_map(fn($number): int => $number ** 3, [2, 4, 5])); // array(3) { [0]=> int(8) [1]=> int(64) [2]=> int(125) } array_merge_recursive int(2) [1]=> int(4) [2]=> int(5) [3]=> int(2) [4]=> int(4) [5]=> int(5) } var_dump(array_merge_recursive([2, 4, 5], ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'])); // array(6) { [0]=> int(2) [1]=> int(4) [2]=> int(5) [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [\"baz\"]=> string(4) \"bird\" } var_dump(array_merge_recursive(['foo' => 'cat', 'bar' => 'dog'], ['foo' => 'dog', 'bar' => 'dog'])); // array(2) { [\"foo\"]=> array(2) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" } [\"bar\"]=> array(2) { [0]=> string(3) \"dog\" [1]=> string(3) \"dog\" } } var_dump(array_merge_recursive(['foo' => 'cat', 'bar' => ['dog']], ['foo' => 'dog', 'bar' => 'cat'])); // array(2) { [\"foo\"]=> array(2) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" } [\"bar\"]=> array(2) { [0]=> string(3) \"dog\" [1]=> string(3) \"cat\" } } var_dump(array_merge_recursive(['foo' => ['bar' => 'cat'], 2], [4, 'foo' => ['bar' => 'dog', 'bird']])); // array(3) { [\"foo\"]=> array(2) { [\"bar\"]=> array(2) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" } [0]=> string(4) \"bird\" } [0]=> int(2) [1]=> int(4) } array_merge int(2) [1]=> int(4) [2]=> int(5) [3]=> int(2) [4]=> int(4) [5]=> int(5) } var_dump(array_merge([2, 4, 5], ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'])); // array(6) { [0]=> int(2) [1]=> int(4) [2]=> int(5) [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [\"baz\"]=> string(4) \"bird\" } var_dump(array_merge(['foo' => 'cat', 'bar' => 'dog'], ['foo' => 'dog', 'bar' => 'cat'])); // array(2) { [\"foo\"]=> string(3) \"dog\" [\"bar\"]=> string(3) \"cat\" } var_dump(array_merge(['foo' => 'cat', 'bar' => ['dog']], ['foo' => 'dog', 'bar' => 'cat'])); // array(2) { [\"foo\"]=> string(3) \"dog\" [\"bar\"]=> string(3) \"cat\" } var_dump(array_merge(['foo' => ['bar' => 'cat'], 2], [4, 'foo' => ['bar' => 'dog', 'bird']])); // array(3) { [\"foo\"]=> array(2) { [\"bar\"]=> string(3) \"dog\" [0]=> string(4) \"bird\" } [0]=> int(2) [1]=> int(4) } array_multisort int(0) [1]=> int(1) [2]=> int(2) [3]=> int(2) [4]=> int(4) [5]=> int(5) } $foo = [2, 4, 5, 0, 1, 2]; $bar = [10, 100, 0, 100, 50, 0]; var_dump(array_multisort($foo, $bar)); // bool(true) var_dump($foo); // array(6) { [0]=> int(0) [1]=> int(1) [2]=> int(2) [3]=> int(2) [4]=> int(4) [5]=> int(5) } var_dump($bar); // array(6) { [0]=> int(100) [1]=> int(50) [2]=> int(0) [3]=> int(10) [4]=> int(100) [5]=> int(0) } $foo = ['10', 11, 100, 100, 'a']; $bar = [1, 2, '2', 3, 1]; var_dump(array_multisort($foo, SORT_REGULAR, $bar)); // bool(true) var_dump($foo); // array(5) { [0]=> string(2) \"10\" [1]=> string(1) \"a\" [2]=> int(11) [3]=> int(100) [4]=> int(100) } var_dump($bar); // array(5) { [0]=> int(1) [1]=> int(1) [2]=> int(2) [3]=> string(1) \"2\" [4]=> int(3) } $foo = ['foo' => '2cat', 'bar' => 'dog', 'baz' => '0bird']; $bar = [2, 4, 5]; var_dump(array_multisort($foo, SORT_NUMERIC, $bar)); // bool(true) var_dump($foo); // array(3) { [\"bar\"]=> string(3) \"dog\" [\"baz\"]=> string(5) \"0bird\" [\"foo\"]=> string(4) \"2cat\" } var_dump($bar); // array(3) { [0]=> int(4) [1]=> int(5) [2]=> int(2) } $foo = ['10', 11, 100, 100, 'a']; $bar = [1, 2, '2', 3, 1]; var_dump(array_multisort($foo, SORT_STRING, $bar)); // bool(true) var_dump($foo); // array(5) { [0]=> string(2) \"10\" [1]=> int(100) [2]=> int(100) [3]=> int(11) [4]=> string(1) \"a\" } var_dump($bar); // array(5) { [0]=> int(1) [1]=> string(1) \"2\" [2]=> int(3) [3]=> int(2) [4]=> int(1) } $foo = ['10', 11, 100, 100, 'a']; $bar = [1, 2, '2', 3, 1]; var_dump(array_multisort($foo, SORT_LOCALE_STRING, $bar)); // bool(true) var_dump($foo); // array(5) { [0]=> string(2) \"10\" [1]=> int(100) [2]=> int(100) [3]=> int(11) [4]=> string(1) \"a\" } var_dump($bar); // array(5) { [0]=> int(1) [1]=> string(1) \"2\" [2]=> int(3) [3]=> int(2) [4]=> int(1) } $foo = ['10', 11, 100, 100, 'a']; $bar = [1, 2, '2', 3, 1]; var_dump(array_multisort($foo, SORT_NATURAL, $bar)); // bool(true) var_dump($foo); // array(5) { [0]=> string(2) \"10\" [1]=> int(11) [2]=> int(100) [3]=> int(100) [4]=> string(1) \"a\" } var_dump($bar); // array(5) { [0]=> int(1) [1]=> int(2) [2]=> string(1) \"2\" [3]=> int(3) [4]=> int(1) } $foo = ['a' => 'Cat1', 'b' => 'cat2', 'c' => 'Cat3', 'd' => 'cat20']; $bar = [2, 4, 5, 0]; var_dump(array_multisort($foo, SORT_STRING, $bar)); // bool(true) var_dump($foo); // array(4) { [\"a\"]=> string(4) \"Cat1\" [\"c\"]=> string(4) \"Cat3\" [\"b\"]=> string(4) \"cat2\" [\"d\"]=> string(5) \"cat20\" } var_dump($bar); // array(4) { [0]=> int(2) [1]=> int(5) [2]=> int(4) [3]=> int(0) } $foo = ['a' => 'Cat1', 'b' => 'cat2', 'c' => 'Cat3', 'd' => 'cat20']; $bar = [2, 4, 5, 0]; var_dump(array_multisort($foo, SORT_STRING | SORT_FLAG_CASE, $bar)); // bool(true) var_dump($foo); // array(4) { [\"a\"]=> string(4) \"Cat1\" [\"b\"]=> string(4) \"cat2\" [\"d\"]=> string(5) \"cat20\" [\"c\"]=> string(4) \"Cat3\" } var_dump($bar); // array(4) { [0]=> int(2) [1]=> int(4) [2]=> int(0) [3]=> int(5) } $foo = ['a' => 'Cat1', 'b' => 'cat2', 'c' => 'Cat3', 'd' => 'cat20']; $bar = [2, 4, 5, 0]; var_dump(array_multisort($foo, SORT_NATURAL | SORT_FLAG_CASE, $bar)); // bool(true) var_dump($foo); // array(4) { [\"a\"]=> string(4) \"Cat1\" [\"b\"]=> string(4) \"cat2\" [\"c\"]=> string(4) \"Cat3\" [\"d\"]=> string(5) \"cat20\" } var_dump($bar); // array(4) { [0]=> int(2) [1]=> int(4) [2]=> int(5) [3]=> int(0) } $foo = ['10', 11, 100, 100, 'a']; $bar = [1, 2, '2', 3, 1]; var_dump(array_multisort($foo, SORT_ASC, SORT_STRING, $bar, SORT_NUMERIC, SORT_DESC)); // bool(true) var_dump($foo); // array(5) { [0]=> string(2) \"10\" [1]=> int(100) [2]=> int(100) [3]=> int(11) [4]=> string(1) \"a\" } var_dump($bar); // array(5) { [0]=> int(1) [1]=> int(3) [2]=> string(1) \"2\" [3]=> int(2) [4]=> int(1) } array_pad int(2) [1]=> int(4) [2]=> int(5) [3]=> int(0) [4]=> int(0) } var_dump(array_pad([2, 4, 5], -6, 1)); // array(6) { [0]=> int(1) [1]=> int(1) [2]=> int(1) [3]=> int(2) [4]=> int(4) [5]=> int(5) } var_dump(array_pad([2, 4, 5], 2, 0)); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } array_pop int(2) [1]=> int(4) } $foo = ['foo' => 'cat', 'bar' => 'dog']; var_dump(array_pop($foo)); // string(3) \"dog\" var_dump($foo); // array(1) { [\"foo\"]=> string(3) \"cat\" } array_product 'cat', 'bar' => 'dog'])); // int(0) array_push int(2) [1]=> int(4) [2]=> int(5) [3]=> array(0) { } } $foo = ['foo' => 'cat', 'bar' => 'dog']; var_dump(array_push($foo, 'bird')); // int(3) var_dump($foo); // array(3) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [0]=> string(4) \"bird\" } $foo = ['foo' => 'cat', 'bar' => 'dog']; var_dump(array_push($foo, [], 'bird')); // int(4) var_dump($foo); // array(4) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [0]=> array(0) { } [1]=> string(4) \"bird\" } array_rand 'cat', 'bar' => 'dog'], 1)); var_dump(array_rand([2, 4, 5, 2, 4, 5], 2)); array_reduce array_replace_recursive int(0) [1]=> int(1) [2]=> int(2) } var_dump(array_replace_recursive(['foo' => 'cat', 'bar' => 'dog'], ['foo' => 'bird'])); // array(2) { [\"foo\"]=> string(4) \"bird\" [\"bar\"]=> string(3) \"dog\" } var_dump(array_replace_recursive(['foo' => 'cat', 'bar' => 'dog'], [0, 1, 2])); // array(5) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [0]=> int(0) [1]=> int(1) [2]=> int(2) } var_dump(array_replace_recursive(['foo' => ['cat'], 'bar' => ['dog', 'bird']], ['foo' => ['horse'], 'bar' => ['dog']])); // array(2) { [\"foo\"]=> array(1) { [0]=> string(5) \"horse\" } [\"bar\"]=> array(2) { [0]=> string(3) \"dog\" [1]=> string(4) \"bird\" } } var_dump(array_replace_recursive(['foo' => 'cat', 'bar' => ['dog', 'bird']], ['foo' => ['horse'], 'bar' => 'dog'])); // array(2) { [\"foo\"]=> array(1) { [0]=> string(5) \"horse\" } [\"bar\"]=> string(3) \"dog\" } var_dump(array_replace_recursive(['foo' => ['cat'], 'bar' => ['dog', 'bird']], ['foo' => 'horse', 'bar' => ['dog']], ['foo' => ['horse'], 'bar' => ['dog']])); // array(2) { [\"foo\"]=> array(1) { [0]=> string(5) \"horse\" } [\"bar\"]=> array(2) { [0]=> string(3) \"dog\" [1]=> string(4) \"bird\" } } array_replace int(0) [1]=> int(1) [2]=> int(2) } var_dump(array_replace(['foo' => 'cat', 'bar' => 'dog'], ['foo' => 'bird'])); // array(2) { [\"foo\"]=> string(4) \"bird\" [\"bar\"]=> string(3) \"dog\" } var_dump(array_replace(['foo' => 'cat', 'bar' => 'dog'], [0, 1, 2])); // array(5) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [0]=> int(0) [1]=> int(1) [2]=> int(2) } var_dump(array_replace(['foo' => ['cat'], 'bar' => ['dog', 'bird']], ['foo' => ['horse'], 'bar' => ['dog']])); // array(2) { [\"foo\"]=> array(1) { [0]=> string(5) \"horse\" } [\"bar\"]=> array(1) { [0]=> string(3) \"dog\" } } var_dump(array_replace(['foo' => 'cat', 'bar' => ['dog', 'bird']], ['foo' => ['horse'], 'bar' => 'dog'])); // array(2) { [\"foo\"]=> array(1) { [0]=> string(5) \"horse\" } [\"bar\"]=> string(3) \"dog\" } var_dump(array_replace(['foo' => ['cat'], 'bar' => ['dog', 'bird']], ['foo' => 'horse', 'bar' => ['dog']], ['foo' => ['horse'], 'bar' => ['dog']])); // array(2) { [\"foo\"]=> array(1) { [0]=> string(5) \"horse\" } [\"bar\"]=> array(1) { [0]=> string(3) \"dog\" } } array_reverse int(5) [1]=> int(4) [2]=> int(2) } var_dump(array_reverse([2, 4, 5], true)); // array(3) { [2]=> int(5) [1]=> int(4) [0]=> int(2) } var_dump(array_reverse(['foo' => 'cat', 'bar' => 'dog'])); // array(2) { [\"bar\"]=> string(3) \"dog\" [\"foo\"]=> string(3) \"cat\" } array_search 'cat', 'bar' => 'dog'])); // string(3) \"foo\" var_dump(array_search('CAT', ['foo' => 'cat', 'bar' => 'dog'])); // bool(false) var_dump(array_search('5', [2, 4, 5])); // int(2) var_dump(array_search('5', [2, 4, 5], true)); // bool(false) var_dump(array_search(5, [2, 4, 5, 5, 5, 5])); // int(2) array_shift int(4) [1]=> int(5) } $foo = ['foo' => 'cat', 'bar' => 'dog']; var_dump(array_shift($foo)); // string(3) \"cat\" var_dump($foo); // array(1) { [\"bar\"]=> string(3) \"dog\" } array_slice string(1) \"c\" [1]=> string(1) \"d\" [2]=> string(1) \"e\" } var_dump(array_slice(['a', 'b', 'c', 'd', 'e'], 2, 0)); // array(0) { } var_dump(array_slice(['a', 'b', 'c', 'd', 'e'], 2, 1)); // array(1) { [0]=> string(1) \"c\" } var_dump(array_slice(['a', 'b', 'c', 'd', 'e'], 2, -1)); // array(2) { [0]=> string(1) \"c\" [1]=> string(1) \"d\" } var_dump(array_slice(['a', 'b', 'c', 'd', 'e'], -2)); // array(2) { [0]=> string(1) \"d\" [1]=> string(1) \"e\" } var_dump(array_slice(['a', 'b', 'c', 'd', 'e'], -2, 1)); // array(1) { [0]=> string(1) \"d\" } var_dump(array_slice(['a', 'b', 'c', 'd', 'e'], -2, -1)); // array(1) { [0]=> string(1) \"d\" } var_dump(array_slice(['a', 'b', 'c', 'd', 'e'], -2, -1, true)); // array(1) { [3]=> string(1) \"d\" } array_splice string(1) \"c\" [1]=> string(1) \"d\" [2]=> string(1) \"e\" } var_dump($foo); // array(2) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, 2, 0)); // array(0) { } var_dump($foo); // array(5) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" [3]=> string(1) \"d\" [4]=> string(1) \"e\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, 2, 1)); // array(1) { [0]=> string(1) \"c\" } var_dump($foo); // array(4) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"d\" [3]=> string(1) \"e\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, 2, -1)); // array(2) { [0]=> string(1) \"c\" [1]=> string(1) \"d\" } var_dump($foo); // array(3) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"e\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, -2)); // array(2) { [0]=> string(1) \"d\" [1]=> string(1) \"e\" } var_dump($foo); // array(3) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, -2, 1)); // array(1) { [0]=> string(1) \"d\" } var_dump($foo); // array(4) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" [3]=> string(1) \"e\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, -2, -1)); // array(1) { [0]=> string(1) \"d\" } var_dump($foo); // array(4) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" [3]=> string(1) \"e\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, -2, -1, 'x')); // array(1) { [0]=> string(1) \"d\" } var_dump($foo); // array(5) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" [3]=> string(1) \"x\" [4]=> string(1) \"e\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, -2, -1, ['x'])); // array(1) { [0]=> string(1) \"d\" } var_dump($foo); // array(5) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" [3]=> string(1) \"x\" [4]=> string(1) \"e\" } $foo = ['a', 'b', 'c', 'd', 'e']; var_dump(array_splice($foo, -2, -1, ['x', 'y', 'z'])); // array(1) { [0]=> string(1) \"d\" } var_dump($foo); // array(7) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" [3]=> string(1) \"x\" [4]=> string(1) \"y\" [5]=> string(1) \"z\" [6]=> string(1) \"e\" } array_sum array_udiff_assoc $b) ? 1 : -1; } var_dump(array_udiff_assoc([2, 4, 5], [2, 4, 5], 'foo')); // array(0) { } var_dump(array_udiff_assoc([2, 4, 5], [2], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_udiff_assoc([2, 4, 5], ['2', '04', '05'], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_udiff_assoc(['foo' => 'cat'], ['bar' => 'dog'], 'foo')); // array(1) { [\"foo\"]=> string(3) \"cat\" } var_dump(array_udiff_assoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_udiff_uassoc $b) ? 1 : -1; } /** * Return the result of the comparison. * * @param string $a * @param string $b * @return int */ function bar(string $a, string $b): int { if ($a === $b) { return 0; } return ($a > $b) ? 1 : -1; } var_dump(array_udiff_uassoc([2, 4, 5], [2, 4, 5], 'foo', 'bar')); // array(0) { } var_dump(array_udiff_uassoc([2, 4, 5], [2], 'foo', 'bar')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_udiff_uassoc([2, 4, 5], ['2', '04', '05'], 'foo', 'bar')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_udiff_uassoc(['foo' => 'cat'], ['bar' => 'dog'], 'foo', 'bar')); // array(1) { [\"foo\"]=> string(3) \"cat\" } var_dump(array_udiff_uassoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo', 'bar')); // array(0) { } array_udiff $b) ? 1 : -1; } var_dump(array_udiff([2, 4, 5], [2, 4, 5], 'foo')); // array(0) { } var_dump(array_udiff([2, 4, 5], ['2'], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_udiff([2, 4, 5], ['2', '04', '05'], 'foo')); // array(2) { [1]=> int(4) [2]=> int(5) } var_dump(array_udiff(['foo' => 'cat'], ['bar' => 'dog'], 'foo')); // array(1) { [\"foo\"]=> string(3) \"cat\" } var_dump(array_udiff(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_uintersect_assoc $b) ? 1 : -1; } var_dump(array_uintersect_assoc([2, 4, 5], [2, 4, 5], 'foo')); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_uintersect_assoc([2, 4, 5], [2], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_uintersect_assoc([2, 4, 5], ['2', '04', '05'], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_uintersect_assoc(['foo' => 'cat'], ['bar' => 'dog'], 'foo')); // array(0) { } var_dump(array_uintersect_assoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_uintersect_uassoc $b) ? 1 : -1; } /** * Return the result of the comparison. * * @param string $a * @param string $b * @return int */ function bar(string $a, string $b): int { if ($a === $b) { return 0; } return ($a > $b) ? 1 : -1; } var_dump(array_uintersect_uassoc([2, 4, 5], [2, 4, 5], 'foo', 'bar')); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_uintersect_uassoc([2, 4, 5], [2], 'foo', 'bar')); // array(1) { [0]=> int(2) } var_dump(array_uintersect_uassoc([2, 4, 5], ['2', '04', '05'], 'foo', 'bar')); // array(1) { [0]=> int(2) } var_dump(array_uintersect_uassoc(['foo' => 'cat'], ['bar' => 'dog'], 'foo', 'bar')); // array(0) { } var_dump(array_uintersect_uassoc(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo', 'bar')); // array(0) { } array_uintersect $b) ? 1 : -1; } var_dump(array_uintersect([2, 4, 5], [2, 4, 5], 'foo')); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_uintersect([2, 4, 5], [2], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_uintersect([2, 4, 5], ['2', '04', '05'], 'foo')); // array(1) { [0]=> int(2) } var_dump(array_uintersect(['foo' => 'cat'], ['bar' => 'dog'], 'foo')); // array(0) { } var_dump(array_uintersect(['foo' => 'cat', 'bar' => 'dog'], ['bar' => 'dog', 'baz' => 'bird'], ['foo' => 'cat', 'baz' => 'bird'], 'foo')); // array(0) { } array_unique int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_unique([2, 4, 5, '2', '4', 5])); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_unique(['foo' => '2cat', 'bar' => '2dog', 'baz' => '2bird', 'qux' => '2cat'], SORT_REGULAR)); // array(3) { [\"foo\"]=> string(4) \"2cat\" [\"bar\"]=> string(4) \"2dog\" [\"baz\"]=> string(5) \"2bird\" } var_dump(array_unique(['foo' => '2cat', 'bar' => '2dog', 'baz' => '2bird', 'qux' => '2cat'], SORT_NUMERIC)); // array(1) { [\"foo\"]=> string(4) \"2cat\" } var_dump(array_unique([2, 4, 5, '02', '04', '05'], SORT_STRING)); // array(6) { [0]=> int(2) [1]=> int(4) [2]=> int(5) [3]=> string(2) \"02\" [4]=> string(2) \"04\" [5]=> string(2) \"05\" } var_dump(array_unique([2, 4, 5, '02', '04', '05'], SORT_LOCALE_STRING)); // array(6) { [0]=> int(2) [1]=> int(4) [2]=> int(5) [3]=> string(2) \"02\" [4]=> string(2) \"04\" [5]=> string(2) \"05\" } array_unshift int(2) [1]=> int(2) [2]=> int(4) [3]=> int(5) } $foo = [2, 4, 5]; var_dump(array_unshift($foo, 2, 4, 5)); // int(6) var_dump($foo); // array(6) { [0]=> int(2) [1]=> int(4) [2]=> int(5) [3]=> int(2) [4]=> int(4) [5]=> int(5) } $foo = [2, 4, 5]; var_dump(array_unshift($foo, ['foo' => 'cat', 'bar' => 'dog'])); // int(4) var_dump($foo); // array(4) { [0]=> array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } [1]=> int(2) [2]=> int(4) [3]=> int(5) } array_values int(2) [1]=> int(4) [2]=> int(5) } var_dump(array_values(['foo' => 'cat', 'bar' => 'dog'])); // array(2) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" } array_walk_recursive int(8) [1]=> int(64) [2]=> int(125) [3]=> array(3) { [0]=> int(8) [1]=> int(64) [2]=> int(125) } } $foo = [2, 4, 5, [2, 4, 5]]; var_dump(array_walk_recursive($foo, 'bar', 1)); // bool(true) var_dump($foo); // array(4) { [0]=> int(3) [1]=> int(5) [2]=> int(6) [3]=> array(3) { [0]=> int(3) [1]=> int(5) [2]=> int(6) } } array_walk int(8) [1]=> int(64) [2]=> int(125) } $foo = [2, 4, 5]; var_dump(array_walk($foo, 'bar', 1)); // bool(true) var_dump($foo); // array(3) { [0]=> int(3) [1]=> int(5) [2]=> int(6) } array int(2) [1]=> int(4) [2]=> int(5) } var_dump(array('foo' => 'cat', 'bar' => 'dog')); // array(2) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } var_dump(array('foo' => 'cat', 2, 4, 5)); // array(4) { [\"foo\"]=> string(3) \"cat\" [0]=> int(2) [1]=> int(4) [2]=> int(5) } arsort int(5) [1]=> int(4) [0]=> int(2) [5]=> int(2) [4]=> int(1) [3]=> int(0) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(arsort($foo)); // bool(true) var_dump($foo); // array(3) { [\"bar\"]=> string(3) \"dog\" [\"foo\"]=> string(3) \"cat\" [\"baz\"]=> string(4) \"bird\" } $foo = ['2', 4, '5', 0, '1', 2]; var_dump(arsort($foo, SORT_REGULAR)); // bool(true) var_dump($foo); // array(6) { [2]=> string(1) \"5\" [1]=> int(4) [0]=> string(1) \"2\" [5]=> int(2) [4]=> string(1) \"1\" [3]=> int(0) } $foo = ['foo' => '2cat', 'bar' => '1dog', 'baz' => '0bird']; var_dump(arsort($foo, SORT_NUMERIC)); // bool(true) var_dump($foo); // array(3) { [\"foo\"]=> string(4) \"2cat\" [\"bar\"]=> string(4) \"1dog\" [\"baz\"]=> string(5) \"0bird\" } $foo = [20, 4, 5, 0, 1, 22]; var_dump(arsort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(6) { [2]=> int(5) [1]=> int(4) [5]=> int(22) [0]=> int(20) [4]=> int(1) [3]=> int(0) } $foo = [20, 4, 5, 0, 1, 22]; var_dump(arsort($foo, SORT_LOCALE_STRING)); // bool(true) var_dump($foo); // array(6) { [2]=> int(5) [1]=> int(4) [5]=> int(22) [0]=> int(20) [4]=> int(1) [3]=> int(0) } $foo = ['foo' => 'cat1', 'bar' => 'cat12', 'baz' => 'cat10', 'qux' => 'cat2']; var_dump(arsort($foo, SORT_NATURAL)); // bool(true) var_dump($foo); // array(4) { [\"bar\"]=> string(5) \"cat12\" [\"baz\"]=> string(5) \"cat10\" [\"qux\"]=> string(4) \"cat2\" [\"foo\"]=> string(4) \"cat1\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(arsort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [\"qux\"]=> string(5) \"cat20\" [\"bar\"]=> string(4) \"cat2\" [\"baz\"]=> string(4) \"Cat3\" [\"foo\"]=> string(4) \"Cat1\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(arsort($foo, SORT_STRING | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"baz\"]=> string(4) \"Cat3\" [\"qux\"]=> string(5) \"cat20\" [\"bar\"]=> string(4) \"cat2\" [\"foo\"]=> string(4) \"Cat1\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(arsort($foo, SORT_NATURAL | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"qux\"]=> string(5) \"cat20\" [\"baz\"]=> string(4) \"Cat3\" [\"bar\"]=> string(4) \"cat2\" [\"foo\"]=> string(4) \"Cat1\" } asort int(0) [4]=> int(1) [0]=> int(2) [5]=> int(2) [1]=> int(4) [2]=> int(5) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(asort($foo)); // bool(true) var_dump($foo); // array(3) { [\"baz\"]=> string(4) \"bird\" [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } $foo = ['2', 4, '5', 0, '1', 2]; var_dump(asort($foo, SORT_REGULAR)); // bool(true) var_dump($foo); // array(6) { [3]=> int(0) [4]=> string(1) \"1\" [0]=> string(1) \"2\" [5]=> int(2) [1]=> int(4) [2]=> string(1) \"5\" } $foo = ['foo' => '2cat', 'bar' => '1dog', 'baz' => '0bird']; var_dump(asort($foo, SORT_NUMERIC)); // bool(true) var_dump($foo); // array(3) { [\"baz\"]=> string(5) \"0bird\" [\"bar\"]=> string(4) \"1dog\" [\"foo\"]=> string(4) \"2cat\" } $foo = [20, 4, 5, 0, 1, 22]; var_dump(asort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(6) { [3]=> int(0) [4]=> int(1) [0]=> int(20) [5]=> int(22) [1]=> int(4) [2]=> int(5) } $foo = [20, 4, 5, 0, 1, 22]; var_dump(asort($foo, SORT_LOCALE_STRING)); // bool(true) var_dump($foo); // array(6) { [3]=> int(0) [4]=> int(1) [0]=> int(20) [5]=> int(22) [1]=> int(4) [2]=> int(5) } $foo = ['foo' => 'cat1', 'bar' => 'cat12', 'baz' => 'cat10', 'qux' => 'cat2']; var_dump(asort($foo, SORT_NATURAL)); // bool(true) var_dump($foo); // array(4) { [\"foo\"]=> string(4) \"cat1\" [\"qux\"]=> string(4) \"cat2\" [\"baz\"]=> string(5) \"cat10\" [\"bar\"]=> string(5) \"cat12\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(asort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [\"foo\"]=> string(4) \"Cat1\" [\"baz\"]=> string(4) \"Cat3\" [\"bar\"]=> string(4) \"cat2\" [\"qux\"]=> string(5) \"cat20\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(asort($foo, SORT_STRING | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"foo\"]=> string(4) \"Cat1\" [\"bar\"]=> string(4) \"cat2\" [\"qux\"]=> string(5) \"cat20\" [\"baz\"]=> string(4) \"Cat3\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(asort($foo, SORT_NATURAL | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"foo\"]=> string(4) \"Cat1\" [\"bar\"]=> string(4) \"cat2\" [\"baz\"]=> string(4) \"Cat3\" [\"qux\"]=> string(5) \"cat20\" } compact string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } $foo = 'cat'; $bar = 'dog'; $baz = 'baz'; $qux = ['cat', 'dog', 'baz', 'qux']; var_dump(compact('foo', 'bar', 'baz', 'qux')); // array(4) { [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" [\"baz\"]=> string(3) \"baz\" [\"qux\"]=> array(4) { [0]=> string(3) \"cat\" [1]=> string(3) \"dog\" [2]=> string(3) \"baz\" [3]=> string(3) \"qux\" } } count 'cat', 'bar' => 'dog'])); // int(2) var_dump(count([[2, 4, 5], ['foo' => 'cat', 'bar' => 'dog']])); // int(2) var_dump(count([[2, 4, 5], ['foo' => 'cat', 'bar' => 'dog']], COUNT_RECURSIVE)); // int(7) current 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(current($foo)); // string(3) \"cat\" var_dump(next($foo)); // string(3) \"dog\" var_dump(current($foo)); // string(3) \"dog\" var_dump(next($foo)); // string(4) \"bird\" var_dump(current($foo)); // string(4) \"bird\" end 'cat', 'bar' => 'dog', 'qux' => 'bird']; var_dump(current($foo)); // string(3) \"cat\" var_dump(end($foo)); // string(4) \"bird\" var_dump(current($foo)); // string(4) \"bird\" var_dump(prev($foo)); // string(3) \"dog\" var_dump(current($foo)); // string(3) \"dog\" var_dump(end($foo)); // string(4) \"bird\" var_dump(current($foo)); // string(4) \"bird\" extract 'cat', 'bar' => 'dog', 'baz' => 'bird'])); // int(3) var_dump($foo); // string(3) \"cat\" var_dump($bar); // string(3) \"dog\" var_dump($baz); // string(4) \"bird\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; var_dump(extract(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'], EXTR_OVERWRITE)); // int(3) var_dump($foo); // string(3) \"cat\" var_dump($bar); // string(3) \"dog\" var_dump($baz); // string(4) \"bird\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; var_dump(extract(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'], EXTR_SKIP)); // int(0) var_dump($foo); // string(3) \"foo\" var_dump($bar); // string(3) \"bar\" var_dump($baz); // string(3) \"baz\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; var_dump(extract(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird', 'qux' => 'horse'], EXTR_PREFIX_SAME, 'prefix')); // int(4) var_dump($prefix_foo); // string(3) \"cat\" var_dump($prefix_bar); // string(3) \"dog\" var_dump($prefix_baz); // string(4) \"bird\" var_dump($qux); // string(5) \"horse\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; var_dump(extract(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird', 'qux' => 'horse'], EXTR_PREFIX_ALL, 'prefix')); // int(4) var_dump($prefix_foo); // string(3) \"cat\" var_dump($prefix_bar); // string(3) \"dog\" var_dump($prefix_baz); // string(4) \"bird\" var_dump($prefix_qux); // string(5) \"horse\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; var_dump(extract([0 => 'cat', 1 => 'dog', 'baz' => 'bird'], EXTR_PREFIX_INVALID, 'prefix')); // int(3) var_dump($prefix_0); // string(3) \"cat\" var_dump($prefix_1); // string(3) \"dog\" var_dump($baz); // string(4) \"bird\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; var_dump(extract(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird', 'test' => 'horse'], EXTR_IF_EXISTS)); // int(3) var_dump($foo); // string(3) \"cat\" var_dump($bar); // string(3) \"dog\" var_dump($baz); // string(4) \"bird\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; var_dump(extract(['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird', 'test' => 'horse'], EXTR_PREFIX_IF_EXISTS, 'prefix')); // int(3) var_dump($prefix_foo); // string(3) \"cat\" var_dump($prefix_bar); // string(3) \"dog\" var_dump($prefix_baz); // string(4) \"bird\" var_dump($test); // string(5) \"horse\" $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; $array = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(extract($array, EXTR_PREFIX_ALL | EXTR_REFS, 'prefix')); // int(3) var_dump($prefix_foo); // string(3) \"cat\" var_dump($prefix_bar); // string(3) \"dog\" var_dump($prefix_baz); // string(4) \"bird\" list($prefix_foo, $prefix_bar, $prefix_baz) = [1, 11, 111]; var_dump($array); // array(3) { [\"foo\"]=> &int(1) [\"bar\"]=> &int(11) [\"baz\"]=> &int(111) } in_array 'cat', 'bar' => 'dog', 'baz' => 'bird'])); // bool(true) var_dump(in_array('CAT', ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird'])); // bool(false) var_dump(in_array('5', [2, 4, 5])); // bool(true) var_dump(in_array('5', [2, 4, 5], true)); // bool(false) key_exists 'cat', 'bar' => 'dog', 'baz' => 'bird'])); // bool(true) key 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(key($foo)); // string(3) \"foo\" var_dump(next($foo)); // string(3) \"dog\" var_dump(key($foo)); // string(3) \"bar\" var_dump(next($foo)); // string(4) \"bird\" var_dump(key($foo)); // string(3) \"baz\" krsort int(2) [4]=> int(1) [3]=> int(0) [2]=> int(5) [1]=> int(4) [0]=> int(2) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(krsort($foo)); // bool(true) var_dump($foo); // array(3) { [\"foo\"]=> string(3) \"cat\" [\"baz\"]=> string(4) \"bird\" [\"bar\"]=> string(3) \"dog\" } $foo = ['2', 4, '5', 0, '1', 2]; var_dump(krsort($foo, SORT_REGULAR)); // bool(true) var_dump($foo); // array(6) { [5]=> int(2) [4]=> string(1) \"1\" [3]=> int(0) [2]=> string(1) \"5\" [1]=> int(4) [0]=> string(1) \"2\" } $foo = ['2cat' => 'foo', '1dog' => 'bar', '0bird' => 'baz']; var_dump(krsort($foo, SORT_NUMERIC)); // bool(true) var_dump($foo); // array(3) { [\"2cat\"]=> string(3) \"foo\" [\"1dog\"]=> string(3) \"bar\" [\"0bird\"]=> string(3) \"baz\" } $foo = ['cat1' => 'foo', 'cat12' => 'bar', 'cat10' => 'baz', 'cat2' => 'qux']; var_dump(krsort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [\"cat2\"]=> string(3) \"qux\" [\"cat12\"]=> string(3) \"bar\" [\"cat10\"]=> string(3) \"baz\" [\"cat1\"]=> string(3) \"foo\" } $foo = ['cat1' => 'foo', 'cat12' => 'bar', 'cat10' => 'baz', 'cat2' => 'qux']; var_dump(krsort($foo, SORT_LOCALE_STRING)); // bool(true) var_dump($foo); // array(4) { [\"cat2\"]=> string(3) \"qux\" [\"cat12\"]=> string(3) \"bar\" [\"cat10\"]=> string(3) \"baz\" [\"cat1\"]=> string(3) \"foo\" } $foo = ['cat1' => 'foo', 'cat12' => 'bar', 'cat10' => 'baz', 'cat2' => 'qux']; var_dump(krsort($foo, SORT_NATURAL)); // bool(true) var_dump($foo); // array(4) { [\"cat12\"]=> string(3) \"bar\" [\"cat10\"]=> string(3) \"baz\" [\"cat2\"]=> string(3) \"qux\" [\"cat1\"]=> string(3) \"foo\" } $foo = ['Cat1' => 'foo', 'cat2' => 'bar', 'Cat3' => 'baz', 'cat20' => 'qux']; var_dump(krsort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [\"cat20\"]=> string(3) \"qux\" [\"cat2\"]=> string(3) \"bar\" [\"Cat3\"]=> string(3) \"baz\" [\"Cat1\"]=> string(3) \"foo\" } $foo = ['Cat1' => 'foo', 'cat2' => 'bar', 'Cat3' => 'baz', 'cat20' => 'qux']; var_dump(krsort($foo, SORT_STRING | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"Cat3\"]=> string(3) \"baz\" [\"cat20\"]=> string(3) \"qux\" [\"cat2\"]=> string(3) \"bar\" [\"Cat1\"]=> string(3) \"foo\" } $foo = ['Cat1' => 'foo', 'cat2' => 'bar', 'Cat3' => 'baz', 'cat20' => 'qux']; var_dump(krsort($foo, SORT_NATURAL | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"cat20\"]=> string(3) \"qux\" [\"Cat3\"]=> string(3) \"baz\" [\"cat2\"]=> string(3) \"bar\" [\"Cat1\"]=> string(3) \"foo\" } ksort int(2) [1]=> int(4) [2]=> int(5) [3]=> int(0) [4]=> int(1) [5]=> int(2) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(ksort($foo)); // bool(true) var_dump($foo); // array(3) { [\"bar\"]=> string(3) \"dog\" [\"baz\"]=> string(4) \"bird\" [\"foo\"]=> string(3) \"cat\" } $foo = ['2', 4, '5', 0, '1', 2]; var_dump(ksort($foo, SORT_REGULAR)); // bool(true) var_dump($foo); // array(6) { [0]=> string(1) \"2\" [1]=> int(4) [2]=> string(1) \"5\" [3]=> int(0) [4]=> string(1) \"1\" [5]=> int(2) } $foo = ['2cat' => 'foo', '1dog' => 'bar', '0bird' => 'baz']; var_dump(ksort($foo, SORT_NUMERIC)); // bool(true) var_dump($foo); // array(3) { [\"0bird\"]=> string(3) \"baz\" [\"1dog\"]=> string(3) \"bar\" [\"2cat\"]=> string(3) \"foo\" } $foo = ['cat1' => 'foo', 'cat12' => 'bar', 'cat10' => 'baz', 'cat2' => 'qux']; var_dump(ksort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [\"cat1\"]=> string(3) \"foo\" [\"cat10\"]=> string(3) \"baz\" [\"cat12\"]=> string(3) \"bar\" [\"cat2\"]=> string(3) \"qux\" } $foo = ['cat1' => 'foo', 'cat12' => 'bar', 'cat10' => 'baz', 'cat2' => 'qux']; var_dump(ksort($foo, SORT_LOCALE_STRING)); // bool(true) var_dump($foo); // array(4) { [\"cat1\"]=> string(3) \"foo\" [\"cat10\"]=> string(3) \"baz\" [\"cat12\"]=> string(3) \"bar\" [\"cat2\"]=> string(3) \"qux\" } $foo = ['cat1' => 'foo', 'cat12' => 'bar', 'cat10' => 'baz', 'cat2' => 'qux']; var_dump(ksort($foo, SORT_NATURAL)); // bool(true) var_dump($foo); // array(4) { [\"cat1\"]=> string(3) \"foo\" [\"cat2\"]=> string(3) \"qux\" [\"cat10\"]=> string(3) \"baz\" [\"cat12\"]=> string(3) \"bar\" } $foo = ['Cat1' => 'foo', 'cat2' => 'bar', 'Cat3' => 'baz', 'cat20' => 'qux']; var_dump(ksort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [\"Cat1\"]=> string(3) \"foo\" [\"Cat3\"]=> string(3) \"baz\" [\"cat2\"]=> string(3) \"bar\" [\"cat20\"]=> string(3) \"qux\" } $foo = ['Cat1' => 'foo', 'cat2' => 'bar', 'Cat3' => 'baz', 'cat20' => 'qux']; var_dump(ksort($foo, SORT_STRING | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"Cat1\"]=> string(3) \"foo\" [\"cat2\"]=> string(3) \"bar\" [\"cat20\"]=> string(3) \"qux\" [\"Cat3\"]=> string(3) \"baz\" } $foo = ['Cat1' => 'foo', 'cat2' => 'bar', 'Cat3' => 'baz', 'cat20' => 'qux']; var_dump(ksort($foo, SORT_NATURAL | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [\"Cat1\"]=> string(3) \"foo\" [\"cat2\"]=> string(3) \"bar\" [\"Cat3\"]=> string(3) \"baz\" [\"cat20\"]=> string(3) \"qux\" } list $baz, 'foo' => $foo, 'bar' => $bar) = ['foo' => 'foo', 'bar' => 'bar', 'baz' => 'baz']; var_dump($foo); // string(3) \"foo\" var_dump($bar); // string(3) \"bar\" var_dump($baz); // string(3) \"baz\" list($qux[0], $qux[1], $qux[2]) = [2, 4, 5]; var_dump($qux); // array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(5) } natcasesort int(2) [1]=> int(4) [2]=> int(5) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(natcasesort($foo)); // bool(true) var_dump($foo); // array(3) { [\"baz\"]=> string(4) \"bird\" [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(natcasesort($foo)); // bool(true) var_dump($foo); // array(4) { [\"foo\"]=> string(4) \"Cat1\" [\"bar\"]=> string(4) \"cat2\" [\"baz\"]=> string(4) \"Cat3\" [\"qux\"]=> string(5) \"cat20\" } $foo = [-5, 3, -2, 0, -1000, 9, 1]; var_dump(natcasesort($foo)); // bool(true) var_dump($foo); // array(7) { [2]=> int(-2) [0]=> int(-5) [4]=> int(-1000) [3]=> int(0) [6]=> int(1) [1]=> int(3) [5]=> int(9) } $foo = ['09', '8', '10', '009', '011', '0']; var_dump(natcasesort($foo)); // bool(true) var_dump($foo); // array(6) { [5]=> string(1) \"0\" [1]=> string(1) \"8\" [0]=> string(2) \"09\" [3]=> string(3) \"009\" [2]=> string(2) \"10\" [4]=> string(3) \"011\" } natsort int(2) [1]=> int(4) [2]=> int(5) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(natsort($foo)); // bool(true) var_dump($foo); // array(3) { [\"baz\"]=> string(4) \"bird\" [\"foo\"]=> string(3) \"cat\" [\"bar\"]=> string(3) \"dog\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(natsort($foo)); // bool(true) var_dump($foo); // array(4) { [\"foo\"]=> string(4) \"Cat1\" [\"baz\"]=> string(4) \"Cat3\" [\"bar\"]=> string(4) \"cat2\" [\"qux\"]=> string(5) \"cat20\" } $foo = [-5, 3, -2, 0, -1000, 9, 1]; var_dump(natsort($foo)); // bool(true) var_dump($foo); // array(7) { [2]=> int(-2) [0]=> int(-5) [4]=> int(-1000) [3]=> int(0) [6]=> int(1) [1]=> int(3) [5]=> int(9) } $foo = ['09', '8', '10', '009', '011', '0']; var_dump(natsort($foo)); // bool(true) var_dump($foo); // array(6) { [5]=> string(1) \"0\" [1]=> string(1) \"8\" [0]=> string(2) \"09\" [3]=> string(3) \"009\" [2]=> string(2) \"10\" [4]=> string(3) \"011\" } next 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(current($foo)); // string(3) \"cat\" var_dump(next($foo)); // string(3) \"dog\" var_dump(current($foo)); // string(3) \"dog\" var_dump(next($foo)); // string(4) \"bird\" var_dump(current($foo)); // string(4) \"bird\" pos 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(pos($foo)); // string(3) \"cat\" var_dump(next($foo)); // string(3) \"dog\" var_dump(pos($foo)); // string(3) \"dog\" var_dump(next($foo)); // string(4) \"bird\" var_dump(pos($foo)); // string(4) \"bird\" prev 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(current($foo)); // string(3) \"cat\" var_dump(next($foo)); // string(3) \"dog\" var_dump(current($foo)); // string(3) \"dog\" var_dump(next($foo)); // string(4) \"bird\" var_dump(current($foo)); // string(4) \"bird\" var_dump(prev($foo)); // string(3) \"dog\" var_dump(current($foo)); // string(3) \"dog\" range int(0) [1]=> int(1) [2]=> int(2) [3]=> int(3) [4]=> int(4) [5]=> int(5) } var_dump(range(0, 50, 10)); // array(6) { [0]=> int(0) [1]=> int(10) [2]=> int(20) [3]=> int(30) [4]=> int(40) [5]=> int(50) } var_dump(range(5, 0, -2)); // array(3) { [0]=> int(5) [1]=> int(3) [2]=> int(1) } var_dump(range('a', 'd')); // array(4) { [0]=> string(1) \"a\" [1]=> string(1) \"b\" [2]=> string(1) \"c\" [3]=> string(1) \"d\" } var_dump(range('a', 'd', 2)); // array(2) { [0]=> string(1) \"a\" [1]=> string(1) \"c\" } var_dump(range('d', 'a', 2)); // array(2) { [0]=> string(1) \"d\" [1]=> string(1) \"b\" } reset 'cat', 'bar' => 'dog', 'qux' => 'bird']; var_dump(current($foo)); // string(3) \"cat\" var_dump(next($foo)); // string(3) \"dog\" var_dump(current($foo)); // string(3) \"dog\" var_dump(next($foo)); // string(4) \"bird\" var_dump(current($foo)); // string(4) \"bird\" var_dump(reset($foo)); // string(3) \"cat\" var_dump(current($foo)); // string(3) \"cat\" rsort int(5) [1]=> int(4) [2]=> int(2) [3]=> int(2) [4]=> int(1) [5]=> int(0) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(rsort($foo)); // bool(true) var_dump($foo); // array(3) { [0]=> string(3) \"dog\" [1]=> string(3) \"cat\" [2]=> string(4) \"bird\" } $foo = ['2', 4, '5', 0, '1', 2]; var_dump(rsort($foo, SORT_REGULAR)); // bool(true) var_dump($foo); // array(6) { [0]=> string(1) \"5\" [1]=> int(4) [2]=> string(1) \"2\" [3]=> int(2) [4]=> string(1) \"1\" [5]=> int(0) } $foo = ['foo' => '2cat', 'bar' => '1dog', 'baz' => '0bird']; var_dump(rsort($foo, SORT_NUMERIC)); // bool(true) var_dump($foo); // array(3) { [0]=> string(4) \"2cat\" [1]=> string(4) \"1dog\" [2]=> string(5) \"0bird\" } $foo = [20, 4, 5, 0, 1, 22]; var_dump(rsort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(6) { [0]=> int(5) [1]=> int(4) [2]=> int(22) [3]=> int(20) [4]=> int(1) [5]=> int(0) } $foo = [20, 4, 5, 0, 1, 22]; var_dump(rsort($foo, SORT_LOCALE_STRING)); // bool(true) var_dump($foo); // array(6) { [0]=> int(5) [1]=> int(4) [2]=> int(22) [3]=> int(20) [4]=> int(1) [5]=> int(0) } $foo = ['foo' => 'cat1', 'bar' => 'cat12', 'baz' => 'cat10', 'qux' => 'cat2']; var_dump(rsort($foo, SORT_NATURAL)); // bool(true) var_dump($foo); // array(4) { [0]=> string(5) \"cat12\" [1]=> string(5) \"cat10\" [2]=> string(4) \"cat2\" [3]=> string(4) \"cat1\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(rsort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [0]=> string(5) \"cat20\" [1]=> string(4) \"cat2\" [2]=> string(4) \"Cat3\" [3]=> string(4) \"Cat1\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(rsort($foo, SORT_STRING | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [0]=> string(4) \"Cat3\" [1]=> string(5) \"cat20\" [2]=> string(4) \"cat2\" [3]=> string(4) \"Cat1\" } $foo = ['a' => 'Cat1', 'b' => 'cat2', 'c' => 'Cat3', 'd' => 'cat20']; var_dump(rsort($foo, SORT_NATURAL | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [0]=> string(5) \"cat20\" [1]=> string(4) \"Cat3\" [2]=> string(4) \"cat2\" [3]=> string(4) \"Cat1\" } shuffle 'cat', 'bar' => 'dog']; var_dump(shuffle($foo)); // bool(true) var_dump($foo); $foo = [[2, 4, 5], ['foo' => 'cat', 'bar' => 'dog']]; var_dump(shuffle($foo)); // bool(true) var_dump($foo); sizeof 'cat', 'bar' => 'dog'])); // int(2) var_dump(sizeof([[2, 4, 5], ['foo' => 'cat', 'bar' => 'dog']])); // int(2) var_dump(sizeof([[2, 4, 5], ['foo' => 'cat', 'bar' => 'dog']], COUNT_RECURSIVE)); // int(7) sort int(0) [1]=> int(1) [2]=> int(2) [3]=> int(2) [4]=> int(4) [5]=> int(5) } $foo = ['foo' => 'cat', 'bar' => 'dog', 'baz' => 'bird']; var_dump(sort($foo)); // bool(true) var_dump($foo); // array(3) { [0]=> string(4) \"bird\" [1]=> string(3) \"cat\" [2]=> string(3) \"dog\" } $foo = ['2', 4, '5', 0, '1', 2]; var_dump(sort($foo, SORT_REGULAR)); // bool(true) var_dump($foo); // array(6) { [0]=> int(0) [1]=> string(1) \"1\" [2]=> string(1) \"2\" [3]=> int(2) [4]=> int(4) [5]=> string(1) \"5\" } $foo = ['foo' => '2cat', 'bar' => '1dog', 'baz' => '0bird']; var_dump(sort($foo, SORT_NUMERIC)); // bool(true) var_dump($foo); // array(3) { [0]=> string(5) \"0bird\" [1]=> string(4) \"1dog\" [2]=> string(4) \"2cat\" } $foo = [20, 4, 5, 0, 1, 22]; var_dump(sort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(6) { [0]=> int(0) [1]=> int(1) [2]=> int(20) [3]=> int(22) [4]=> int(4) [5]=> int(5) } $foo = [20, 4, 5, 0, 1, 22]; var_dump(sort($foo, SORT_LOCALE_STRING)); // bool(true) var_dump($foo); // array(6) { [0]=> int(0) [1]=> int(1) [2]=> int(20) [3]=> int(22) [4]=> int(4) [5]=> int(5) } $foo = ['foo' => 'cat1', 'bar' => 'cat12', 'baz' => 'cat10', 'qux' => 'cat2']; var_dump(sort($foo, SORT_NATURAL)); // bool(true) var_dump($foo); // array(4) { [0]=> string(4) \"cat1\" [1]=> string(4) \"cat2\" [2]=> string(5) \"cat10\" [3]=> string(5) \"cat12\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(sort($foo, SORT_STRING)); // bool(true) var_dump($foo); // array(4) { [0]=> string(4) \"Cat1\" [1]=> string(4) \"Cat3\" [2]=> string(4) \"cat2\" [3]=> string(5) \"cat20\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(sort($foo, SORT_STRING | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [0]=> string(4) \"Cat1\" [1]=> string(4) \"cat2\" [2]=> string(5) \"cat20\" [3]=> string(4) \"Cat3\" } $foo = ['foo' => 'Cat1', 'bar' => 'cat2', 'baz' => 'Cat3', 'qux' => 'cat20']; var_dump(sort($foo, SORT_NATURAL | SORT_FLAG_CASE)); // bool(true) var_dump($foo); // array(4) { [0]=> string(4) \"Cat1\" [1]=> string(4) \"cat2\" [2]=> string(4) \"Cat3\" [3]=> string(5) \"cat20\" } uasort $b); } /** * Sort in descending order. * * @param int $a * @param int $b * @return int */ function bar(int $a, int $b): int { return -($a $b); } $foo = [2, 4, 5, 0, 1, 2]; var_dump(uasort($foo, 'foo')); // bool(true) var_dump($foo); // array(6) { [3]=> int(0) [4]=> int(1) [0]=> int(2) [5]=> int(2) [1]=> int(4) [2]=> int(5) } $foo = [2, 4, 5, 0, 1, 2]; var_dump(uasort($foo, 'bar')); // bool(true) var_dump($foo); // array(6) { [2]=> int(5) [1]=> int(4) [0]=> int(2) [5]=> int(2) [4]=> int(1) [3]=> int(0) } uksort $b); } /** * Sort in descending order. * * @param int $a * @param int $b * @return int */ function bar(int $a, int $b): int { return -($a $b); } $foo = [2, 4, 5, 0, 1, 2]; var_dump(uksort($foo, 'foo')); // bool(true) var_dump($foo); // array(6) { [0]=> int(2) [1]=> int(4) [2]=> int(5) [3]=> int(0) [4]=> int(1) [5]=> int(2) } $foo = [2, 4, 5, 0, 1, 2]; var_dump(uksort($foo, 'bar')); // bool(true) var_dump($foo); // array(6) { [5]=> int(2) [4]=> int(1) [3]=> int(0) [2]=> int(5) [1]=> int(4) [0]=> int(2) } usort $b); } /** * Sort by string. * * @param string $a * @param string $b * @return int */ function bar(string $a, string $b): int { return strcmp($a, $b); } $foo = [2, 4, 5, 0, 1, 2]; var_dump(usort($foo, 'foo')); // bool(true) var_dump($foo); // array(6) { [0]=> int(0) [1]=> int(1) [2]=> int(2) [3]=> int(2) [4]=> int(4) [5]=> int(5) } $foo = ['cat', 'dog', 'bird']; var_dump(usort($foo, 'bar')); // bool(true) var_dump($foo); // array(3) { [0]=> string(4) \"bird\" [1]=> string(3) \"cat\" [2]=> string(3) \"dog\" } "},"docs/函数参考/变量与类型相关扩展/类与对象.html":{"url":"docs/函数参考/变量与类型相关扩展/类与对象.html","title":"类与对象","keywords":"","body":"类与对象 class_alias - 为一个类创建别名 class_exists - 检查类是否已定义 get_called_class - 获取后期静态绑定类的名称 get_class_methods - 返回由类的方法名组成的数组 get_class_vars - 返回由类的默认属性组成的数组 get_class - 返回对象的类名 get_declared_classes - 返回由已定义类的名字所组成的数组 get_declared_interfaces - 返回一个数组包含所有已声明的接口 get_declared_traits - 返回所有已定义的 Trait 的数组 get_object_vars - 返回由对象属性组成的关联数组 get_parent_class - 返回对象或类的父类名 interface_exists - 检查接口是否已被定义 is_a - 如果对象属于该类或该类是此对象的父类则返回 true is_subclass_of - 如果此对象是该类的子类，则返回 true method_exists - 检查类的方法是否存在 property_exists - 检查对象或类是否具有该属性 trait_exists - 检查指定的 Trait 是否存在 class_alias class_exists get_called_class get_class_methods string(6) \"public\" [1]=> string(6) \"method\" } var_dump(get_class_methods('Bar')); // array(2) { [0]=> string(6) \"public\" [1]=> string(6) \"method\" } var_dump(get_class_methods($foo)); // array(2) { [0]=> string(6) \"public\" [1]=> string(6) \"method\" } var_dump(get_class_methods($bar)); // array(2) { [0]=> string(6) \"public\" [1]=> string(6) \"method\" } var_dump(Foo::method()); // array(4) { [0]=> string(6) \"public\" [1]=> string(9) \"protected\" [2]=> string(7) \"private\" [3]=> string(6) \"method\" } var_dump(Bar::method()); // array(4) { [0]=> string(6) \"public\" [1]=> string(9) \"protected\" [2]=> string(7) \"private\" [3]=> string(6) \"method\" } get_class_vars string(6) \"public\" } var_dump(get_class_vars('Bar')); // array(1) { [\"public\"]=> string(6) \"public\" } var_dump(Foo::method()); // array(3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(9) \"protected\" [\"private\"]=> NULL } var_dump(Bar::method()); // array(3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(9) \"protected\" [\"private\"]=> NULL } get_class method()); // string(3) \"Foo\" var_dump($bar->method()); // string(3) \"Bar\" get_declared_classes get_declared_interfaces get_declared_traits get_object_vars string(6) \"public\" } var_dump(get_object_vars($bar)); // array(1) { [\"public\"]=> string(6) \"public\" } var_dump($foo->method()); // array(3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(9) \"protected\" [\"private\"]=> NULL } var_dump($bar->method()); // array(3) { [\"public\"]=> string(6) \"public\" [\"protected\"]=> string(9) \"protected\" [\"private\"]=> NULL } get_parent_class interface_exists is_a is_subclass_of method_exists property_exists trait_exists "},"docs/函数参考/变量与类型相关扩展/字符类型检测.html":{"url":"docs/函数参考/变量与类型相关扩展/字符类型检测.html","title":"字符类型检测","keywords":"","body":"字符类型检测 ctype_alnum - 做字母和数字字符检测 ctype_alpha - 做纯字符检测 ctype_cntrl - 做控制字符检测 ctype_digit - 做纯数字检测 ctype_graph - 做可打印字符串检测，空格除外 ctype_lower - 做小写字符检测 ctype_print - 做可打印字符检测 ctype_punct - 检测可打印的字符是不是不包含空白、数字和字母 ctype_space - 做空白字符检测 ctype_upper - 做大写字母检测 ctype_xdigit - 检测字符串是否只包含十六进制字符 ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_graph ctype_lower ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit "},"docs/函数参考/变量与类型相关扩展/过滤器.html":{"url":"docs/函数参考/变量与类型相关扩展/过滤器.html","title":"过滤器","keywords":"","body":"过滤器 filter_has_var - 检测是否存在指定类型的变量 filter_id - 返回与某个特定名称的过滤器相关联的 ID filter_input_array - 获取一系列外部变量，并且可以通过过滤器处理它们 filter_input - 通过名称获取特定的外部变量，并且可以通过过滤器处理它 filter_list - 返回所支持的过滤器列表 filter_var_array - 获取多个变量并且过滤它们 filter_var - 使用特定的过滤器过滤一个变量 filter_has_var filter_id filter_input_array FILTER_VALIDATE_INT, 'boolean' => FILTER_VALIDATE_BOOLEAN, 'float' => FILTER_VALIDATE_FLOAT, 'url' => FILTER_VALIDATE_URL, 'email' => FILTER_VALIDATE_EMAIL, 'ip' => FILTER_VALIDATE_IP ]; var_dump(filter_input_array(INPUT_GET, $filter)); filter_input filter_list filter_var_array '0755', 'boolean' => 'true', 'float' => '122.34343', 'url' => 'https://github.com/', 'email' => 'user@example.com', 'ip' => '2130706433' ]; $filter = [ 'int' => FILTER_VALIDATE_INT, 'boolean' => FILTER_VALIDATE_BOOLEAN, 'float' => FILTER_VALIDATE_FLOAT, 'url' => FILTER_VALIDATE_URL, 'email' => FILTER_VALIDATE_EMAIL, 'ip' => FILTER_VALIDATE_IP ]; var_dump(filter_var_array($data, $filter)); // array(6) { [\"int\"]=> bool(false) [\"boolean\"]=> bool(true) [\"float\"]=> float(122.34343) [\"url\"]=> string(19) \"https://github.com/\" [\"email\"]=> string(16) \"user@example.com\" [\"ip\"]=> bool(false) } filter_var "},"docs/函数参考/变量与类型相关扩展/函数处理.html":{"url":"docs/函数参考/变量与类型相关扩展/函数处理.html","title":"函数处理","keywords":"","body":"函数处理 call_user_func_array - 调用回调函数，并把一个数组参数作为回调函数的参数 call_user_func - 调用回调函数，并把一个参数作为回调函数的参数 forward_static_call_array - 转发调用静态方法，并把一个数组参数作为静态方法的参数 forward_static_call - 转发调用静态方法，并把一个参数作为静态方法的参数 func_get_arg - 返回参数列表的某一项 func_get_args - 返回一个包含函数参数列表的数组 func_num_args - 返回传递给函数的参数个数 function_exists - 如果给定的函数已经被定义就返回 true get_defined_functions - 返回所有已定义函数的数组 register_shutdown_function - 注册一个会在 PHP 中止时执行的函数 register_tick_function - 在每个 Tick 上注册一个执行函数 unregister_tick_function - 取消注册每个 Tick 上执行的函数 call_user_func_array call_user_func forward_static_call_array forward_static_call func_get_arg int(1) [1]=> int(2) [2]=> int(3) } func_get_args int(1) [1]=> int(2) [2]=> int(3) } func_num_args function_exists get_defined_functions register_shutdown_function register_tick_function 0) { $foo += 2; } // string(3) \"foo\" // string(3) \"foo\" // string(3) \"foo\" unregister_tick_function 0) { $foo += 2; } // string(3) \"foo\" "},"docs/函数参考/变量与类型相关扩展/反射.html":{"url":"docs/函数参考/变量与类型相关扩展/反射.html","title":"反射","keywords":"","body":"反射 Reflection — Reflection 类 Reflection::export — 导出一个类 Reflection::getModifierNames — 获取修饰符的名称 ReflectionClass — ReflectionClass 类 ReflectionClass::__construct — 初始化 ReflectionClass 类 ReflectionClass::export — 导出一个类 ReflectionClass::getConstant — 获取定义过的一个常量 ReflectionClass::getConstants — 获取一组常量 ReflectionClass::getConstructor — 获取类的构造函数 ReflectionClass::getDefaultProperties — 获取默认属性 ReflectionClass::getDocComment — 获取文档注释 ReflectionClass::getEndLine — 获取最后一行的行数 ReflectionClass::getExtension — 根据已定义的类获取所在扩展的 ReflectionExtension 对象 ReflectionClass::getExtensionName — 获取定义的类所在的扩展的名称 ReflectionClass::getFileName — 获取定义类的文件名 ReflectionClass::getInterfaceNames — 获取接口名称 ReflectionClass::getInterfaces — 获取接口 ReflectionClass::getMethod — 获取一个类的方法 ReflectionClass::getMethods — 获取方法的数组 ReflectionClass::getModifiers — 获取类的修饰符 ReflectionClass::getName — 获取类名 ReflectionClass::getNamespaceName — 获取命名空间的名称 ReflectionClass::getParentClass — 获取父类 ReflectionClass::getProperties — 获取一组属性 ReflectionClass::getProperty — 获取类的一个属性的 ReflectionProperty ReflectionClass::getReflectionConstant — Gets a ReflectionClassConstant for a class's constant ReflectionClass::getReflectionConstants — Gets class constants ReflectionClass::getShortName — 获取短名 ReflectionClass::getStartLine — 获取起始行号 ReflectionClass::getStaticProperties — 获取静态（static）属性 ReflectionClass::getStaticPropertyValue — 获取静态（static）属性的值 ReflectionClass::getTraitAliases — 返回 trait 别名的一个数组 ReflectionClass::getTraitNames — 返回这个类所使用 traits 的名称的数组 ReflectionClass::getTraits — 返回这个类所使用的 traits 数组 ReflectionClass::hasConstant — 检查常量是否已经定义 ReflectionClass::hasMethod — 检查方法是否已定义 ReflectionClass::hasProperty — 检查属性是否已定义 ReflectionClass::implementsInterface — 接口的实现 ReflectionClass::inNamespace — 检查是否位于命名空间中 ReflectionClass::isAbstract — 检查类是否是抽象类（abstract） ReflectionClass::isAnonymous — 检查类是否是匿名类 ReflectionClass::isCloneable — 返回了一个类是否可复制 ReflectionClass::isFinal — 检查类是否声明为 final ReflectionClass::isInstance — 检查类的实例 ReflectionClass::isInstantiable — 检查类是否可实例化 ReflectionClass::isInterface — 检查类是否是一个接口（interface） ReflectionClass::isInternal — 检查类是否由扩展或核心在内部定义 ReflectionClass::isIterable — Check whether this class is iterable ReflectionClass::isIterateable — 检查是否可迭代（iterateable） ReflectionClass::isSubclassOf — 检查是否为一个子类 ReflectionClass::isTrait — 返回了是否为一个 trait ReflectionClass::isUserDefined — 检查是否由用户定义的 ReflectionClass::newInstance — 从指定的参数创建一个新的类实例 ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。 ReflectionClass::newInstanceWithoutConstructor — 创建一个新的类实例而不调用它的构造函数 ReflectionClass::setStaticPropertyValue — 设置静态属性的值 ReflectionClass::__toString — 返回 ReflectionClass 对象字符串的表示形式。 Reflection Reflection::export Reflection::getModifierNames ReflectionClass ReflectionClass::__construct string(3) \"Foo\" } var_dump(new ReflectionClass(new Foo)); // object(ReflectionClass)#1 (1) { [\"name\"]=> string(3) \"Foo\" } ReflectionClass::export ReflectionClass::getConstant getConstant('constant')); // bool(false) var_dump($foo->getConstant('CONSTANT')); // string(3) \"foo\" ReflectionClass::getConstants getConstants()); // array(1) { [\"CONSTANT\"]=> string(3) \"foo\" } ReflectionClass::getConstructor getConstructor()); // object(ReflectionMethod)#2 (2) { [\"name\"]=> string(11) \"__construct\" [\"class\"]=> string(3) \"Foo\" } ReflectionClass::getDefaultProperties ReflectionClass::getDocComment ReflectionClass::getEndLine ReflectionClass::getExtension ReflectionClass::getExtensionName ReflectionClass::getFileName ReflectionClass::getInterfaceNames ReflectionClass::getInterfaces ReflectionClass::getMethod ReflectionClass::getMethods ReflectionClass::getModifiers ReflectionClass::getName ReflectionClass::getNamespaceName ReflectionClass::getParentClass ReflectionClass::getProperties ReflectionClass::getProperty ReflectionClass::getReflectionConstant ReflectionClass::getReflectionConstants ReflectionClass::getShortName ReflectionClass::getStartLine ReflectionClass::getStaticProperties ReflectionClass::getStaticPropertyValue ReflectionClass::getTraitAliases ReflectionClass::getTraitNames ReflectionClass::getTraits ReflectionClass::hasConstant ReflectionClass::hasMethod ReflectionClass::hasProperty ReflectionClass::implementsInterface ReflectionClass::inNamespace ReflectionClass::isAbstract ReflectionClass::isAnonymous ReflectionClass::isCloneable ReflectionClass::isFinal ReflectionClass::isInstance ReflectionClass::isInstantiable ReflectionClass::isInterface ReflectionClass::isInternal ReflectionClass::isIterable ReflectionClass::isIterateable ReflectionClass::isSubclassOf ReflectionClass::isTrait ReflectionClass::isUserDefined ReflectionClass::newInstance ReflectionClass::newInstanceArgs ReflectionClass::newInstanceWithoutConstructor ReflectionClass::setStaticPropertyValue ReflectionClass::__toString "},"docs/函数参考/变量与类型相关扩展/变量.html":{"url":"docs/函数参考/变量与类型相关扩展/变量.html","title":"变量","keywords":"","body":"变量 boolval - 获取变量的布尔值 debug_zval_dump - 打印变量的相关信息和被引用的次数 doubleval - 获取变量的浮点值 empty - 检查一个变量是否为空 floatval - 获取变量的浮点值 get_defined_vars - 返回由所有已定义变量所组成的数组 get_resource_type - 返回资源类型 gettype - 获取变量的类型 intval - 获取变量的整数值 is_array - 检测变量是否是数组 is_bool - 检测变量是否是布尔型 is_callable - 检测参数是否为合法的可调用结构 is_countable - 检测参数是否为可计数类型 is_double - 检测变量是否是浮点型 is_float - 检测变量是否是浮点型 is_int - 检测变量是否是整数 is_integer - 检测变量是否是整数 is_iterable - 检测变量是否是可迭代类型 is_long - 检测变量是否是整数 is_null - 检测变量是否为 NULL is_numeric - 检测变量是否为数字或数字字符串 is_object - 检测变量是否是一个对象 is_resource - 检测变量是否为资源类型 is_scalar - 检测变量是否是一个标量 is_string - 检测变量是否是字符串 isset - 检测变量是否已设置并且非 NULL print_r - 以易于理解的格式打印变量 serialize - 产生一个可存储的值的表示 settype - 设置变量的类型 strval - 获取变量的字符串值 unserialize - 从已存储的表示中创建 PHP 的值 unset - 释放指定的变量 var_dump - 打印变量的相关信息 var_export - 输出或返回一个变量的字符串表示 boolval debug_zval_dump doubleval empty floatval get_defined_vars get_resource_type gettype intval is_array 'cat', 'bar' => 'dog'])); // bool(true) is_bool is_callable is_countable is_double is_float is_int is_integer is_iterable is_long is_null is_numeric is_object is_resource is_scalar is_string isset print_r 0 [1] => 1 [2] => 2 ) $foo = print_r([0, 1, 2], true); var_dump($foo); // string(49) \"Array ( [0] => 0 [1] => 1 [2] => 2 ) \" serialize settype strval unserialize int(0) [1]=> int(1) [2]=> int(2) } var_dump(unserialize('O:8:\"stdClass\":0:{}')); // object(stdClass)#1 (0) { } unset int(1) [2]=> int(2) } $foo = new stdClass; unset($foo); var_dump($foo); // NULL $foo = 0; $bar = [0, 1, 2]; unset($foo, $bar); var_dump($foo); // NULL var_dump($bar); // NULL var_dump int(0) [1]=> int(1) [2]=> int(2) } var_dump(0, [0, 1, 2], new stdClass); // int(0) array(3) { [0]=> int(0) [1]=> int(1) [2]=> int(2) } object(stdClass)#1 (0) { } var_export 0, 1 => 1, 2 => 2, ) $foo = var_export([0, 1, 2], true); var_dump($foo); // string(39) \"array ( 0 => 0, 1 => 1, 2 => 2, )\" "},"docs/函数参考/XML 操作.html":{"url":"docs/函数参考/XML 操作.html","title":"XML 操作","keywords":"","body":"XML 操作 "},"docs/函数参考/XML 操作/SimpleXML.html":{"url":"docs/函数参考/XML 操作/SimpleXML.html","title":"SimpleXML","keywords":"","body":"SimpleXML "},"docs/函数参考/XML 操作/XML 解析器.html":{"url":"docs/函数参考/XML 操作/XML 解析器.html","title":"XML 解析器","keywords":"","body":"XML 解析器 "},"docs/会话和安全.html":{"url":"docs/会话和安全.html","title":"会话和安全","keywords":"","body":"会话和安全 会话管理基础 和会话安全相关的配置项 "},"docs/会话和安全/会话管理基础.html":{"url":"docs/会话和安全/会话管理基础.html","title":"会话管理基础","keywords":"","body":"会话管理基础 会话安全 严格会话管理 重新生成会话 ID 会话中数据的删除 会话和锁定 活跃会话 会话和自动登录 CSRF 会话安全 会话模块无法保证存储在会话中的信息只能被创建会话的用户本人可见。需要采取额外的手段来确保会话中的机密信息，至于采取何种方式来保护机密信息，取决于在会话中存储的数据。评估会话中存储的数据的重要性，以及为此增加额外的保护机制，通常需要付出一定的代价，同时会降低便利性。例如，如果你需要保护用户免受社会工程学攻击，你需要启用 session.use_only_cookies 选项。这就要求用户在使用过程中，必须把浏览器设置为接受 Cookie ，否则就无法正常使用会话功能了。 有很多种方式都可以导致会话 ID 被泄露给第三方。例如， JavaScript 注入， URL 中包含会话 ID ，数据包侦听， 或者直接访问你的物理设备等。如果会话 ID 被泄漏给第三方，那么第三方就可以通过这个会话 ID 访问全部的资源。首先，如果在 URL 中包含了会话 ID ，并且访问了外部的站点，那么你的会话 ID 可能在外部站点的访问日志中被记录。另外，攻击者也可以监听你的网络通信，如果通信未加密，那么会话 ID 将会在网络中以明文的形式进行传输。针对这种情况的解决方案就是在服务端配置 SSL / TLS ，另外，使用 HSTS 可以达到更高的安全性。注意，即使使用 HTTPS 协议，也无法永远保证机密数据不被泄漏。 严格会话管理 PHP 是以自适应的方式来管理会话的，这种方式使用起来很灵活，但是同样也带来了一定的风险。当启用 session.use_strict_mode 这个配置项，并且所用的会话存储器支持的话，未经初始化的会话 ID 会被拒绝，并为其生成一个全新的会话，这可以避免攻击者使用一个已知的会话 ID 来进行攻击。例如，攻击者可以通过邮件给受害者发送一个包含会话 ID 的链接： http://localhost/index.php?PHPSESSID=123 ，如果启用了 session.use_trans_sid 配置项，那么受害者将会使用攻击者所提供的会话 ID 开始一个新的会话。 在浏览器一侧，可以为用来保存会话 ID 的 Cookie 设置域，路径，仅允许 HTTP 访问，必须使用 HTTPS 访问等安全属性，攻击者可以利用浏览器的这些特性来设置永久可用的会话 ID 。仅仅设置 session.use_only_cookies 配置项无法解决这个问题。设置 session.use_strict_mode = On ，来拒绝未经初始化的会话 ID 。 虽然使用 session.use_strict_mode 配置项可以降低灵活会话管理方式所带来的风险，攻击者还是通过利用 JavaScript 注入等手段，强制用户使用由攻击者创建的并且经过了正常的初始化的会话 ID 。如果已经启用了 session.use_strict_mode 配置项，同时使用基于时间戳的会话管理，并且通过调用 session_regenerate_id() 函数来重新生成会话 ID ，那么，攻击者生成的会话 ID 就可以被删除掉了。 当发生对过期会话访问的时候，你应该保存活跃会话的所有数据，以备后续分析使用。然后让用户退出当前的会话，并且重新登录。防止攻击者继续使用“偷”来的会话。对过期会话数据的访问并不总是意味着正在遭受攻击。不稳定的网络状况，或者不正确的会话删除行为，都会导致合法的用户产生对过期会话数据访问行为。 使用 session_create_id() 函数允许开发者在会话 ID 中增加用户 ID 作为前缀，以确保用户访问到正确对应的会话数据。要使用这个函数，请确保启用了 session.use_strict_mode 配置项，否则恶意用户可能会伪造其他用户的会话 ID 。 重新生成会话 ID 虽然 session.use_strict_mode 配置项可以降低风险，但是还不够。为了确保会话安全，开发者还需要使用 session_regenerate_id() 函数。会话 ID 重新生成机制可以有效的降低会话被窃取的风险，所以，必须周期性的调用 session_regenerate_id() 函数来重新生成会话 ID ，例如，对于机密内容，每隔 15 分钟就重新生成会话 ID 。这样一来，即使会话 ID 被窃取，那么攻击者所得到的会话 ID 也会很快的过期，如果他们进一步访问，就会产生对过期会话数据访问的错误。当用户成功通过认证之后，必须为其重新生成会话 ID 。并且，必须在向 $_SESSION 中保存用户认证信息之前调用 session_regenerate_id() 函数。请确保只有新的会话包含用户认证信息。 开发者不要依赖 session.gc_maxlifetime 配置项。因为攻击者可以在受害者的会话过期之前产生访问，并且维持这个会话的活动，以保证这个会话不会过期。实际上，你需要自己实现基于时间戳的会话数据管理机制。虽然会话管理器可以透明的管理时间戳，但是这个特性尚未完整的实现。在 GC 发生之前，旧的会话数据还得保存，同时，开发者还得保证过期的会话数据已经被移除。但是，开发者又不能立即移除活跃会话中的数据。所以，不要在活跃会话上调用 session_regenerate_id(true) 和 session_destroy() 函数。这听起来有点自相矛盾，但是事实上必须得这么做。默认情况下， session_regenerate_id() 函数不会删除旧的会话，所以即使重生了会话 ID ，旧的会话可能还是可用的。开发者需要使用时间戳等机制，来确保旧的会话数据不会再次被访问。立即删除活跃会话可能会带来非预期的一些影响。例如，在网络状态不稳定，或者有并发请求到达 Web 服务器的情况下， 立即删除活跃会话可能导致个别请求会话失效的问题。立即删除活跃会话也无法检测可能存在的恶意访问。作为替代方案，需要在 $_SESSION 中设置一个很短的过期时间，然后根据这个时间戳来判断后续的访问是被允许的还是被禁止的。在调用 session_regenerate_id() 函数之后，不能立即禁止对旧的会话数据的访问，应该再一小段之间之后再禁止访问。例如，在稳定的网络条件下，可以设置为几秒钟，在不稳定的网络条件下，可以设置为几分钟。如果用户访问了已经过期的会话数据，那么应该禁止访问。建议从会话中移除这个用户的认证信息，因为这看起来像是在遭受攻击。 如果攻击者设置了不可删除的 Cookie ，那么使用 session.use_only_cookies 和 session_regenerate_id() 函数会导致正常用户遭受拒绝服务的问题。如果发生这种情况，请让用户删除 Cookie 并且警告用户他可能面临一些安全问题。攻击者可以通过恶意的 Web 应用、浏览器插件以及对安全性较差的物理设备进行攻击来伪造恶意的 Cookie 。 会话中数据的删除 过期的会话中的数据应该是被删除的，并且不可访问。现在的会话模块尚未很好的支持这种特性。应该尽可能快的删除过期会话中的数据。但是，活跃会话一定不要立即删除。为了能够同时满足这两点要求，你需要自己来实现基于时间戳的会话数据管理机制。在 $_SESSION 中设置会话过期时间戳，并且对其进行管理，以便能够阻止对于过期会话的访问。当发生对于过期会话的访问时，建议从相关用户的所有会话中删除认证信息，并且要求用户重新认证。对于过期会话数据的访问可能是一种攻击行为，为了保护会话数据，你需要追踪每个用户的活跃会话。 当用户处于不稳定的网络，或者 Web 应用存在并发的请求的时候，也可能发生对于过期会话数据的访问。服务器尝试为用户设置新的会话 ID ，但是很可能由于网络原因，导致 Set-Cookie 的数据包无法到达用户的浏览器。当通过 session_regenerate_id() 函数为一个连接生成新的会话 ID 之后，其他的并发连接可能尚未得到这个新的会话 ID 。因此，不能立即阻止对于过期会话数据的访问，而是要延迟一个很小的时间段，这就是为什么需要实现基于时间戳的会话管理。简而言之，不要在调用 session_regenerate_id() 或者 session_destroy() 函数的时候立即删除旧的会话数据，而是要通过一个时间戳来控制后续对于这个旧会话数据的访问。从会话存储中删除数据的工作交给 session_gc() 函数来完成。 会话和锁定 默认情况下，为了保证会话数据在多个请求之间的一致性，对于会话数据的访问是加锁进行的。但是，这种锁定机制也会导致被攻击者利用，来进行对于用户的拒绝服务攻击。为了降低这种风险，请在访问会话数据的时候，尽可能的缩短锁定的时间。当某个请求不需要更新会话数据的时候，使用只读模式访问会话数据。也就是说，开启会话时使用该选项： session_start(['read_and_close' => true]) 。另外，如果需要更新会话数据，那么在更新完毕之后，马上调用 session_commit() 函数来释放对于会话数据的锁。当会话不活跃的时候，当前的会话模块不会检测对于 $_SESSION 的修改。你需要自己来保证在会话处于不活跃状态的时候，不要去修改它。 活跃会话 开发者需要自己来追踪每个用户的活跃会话，要知道每个用户创建了多少活跃会话，每个活跃会话来自哪个 IP 地址，活跃了多长时间等。 PHP 不会自动完成这项工作，需要开发者来完成。有很多种方式可以做到追踪用户的活跃会话。你可以通过在数据库中存储会话信息来跟踪用户会话。由于会话是可以被垃圾收集器收集掉的，所以你也需要处理被收集掉的会话数据，以保证数据库中的数据和真实的活跃会话数据的一致性。一种很简单的方式就是使用用户 ID 作为会话 ID 前缀，并且保存必要的信息到 $_SESSION 中。大部分的数据库产品对于字符串前缀查询都有很好的性能表现。为了实现这种方式，可以使用 session_regenerate_id() 和 session_create_id() 函数。要能够检测对于过期会话数据的访问，基于时间戳的会话数据管理机制是必不可少的。当检测到对于过期会话数据的访问时，你应该从相关用户的活跃会话中删除认证信息，避免攻击者持续使用盗取的会话。 会话和自动登录 开发者不应该通过使用长生命周期的会话 ID 来实现自动登录功能，因为这种方式提高了会话被窃取的风险。开发者应该自己实现自动登录的机制。在使用 setcookie() 函数的时候，传入安全的一次性摘要结果作为自动登录信息。在用户访问的时候，如果发现用户尚未认证，那么就去检查请求中是否包含了有效的一次性登录信息。如果包含有效的一次性登录信息，那么就去认证用户，并且重新生成新的一次性登录信息。自动登录的关键信息一定是只能使用一次，永远不要重复使用一次性登录信息。自动登录信息是长生命周期的认证信息，所以必须要尽可能的妥善保护。可以对于自动登录信息对应的 Cookie 设置路径、仅允许 HTTP 访问、仅允许安全访问等属性来加以保护，并且尽在必要的时候才传送这个 Cookie 。开发者也要提供禁用自动登录的机制，以及删除不再需要的自动登录数据的能力。 CSRF 会话和认证无法避免跨站请求伪造攻击。开发者需要自己来实现保护应用不受 CSRF 攻击的功能。大部分 Web 应用框架都提供了 CSRF 保护的特性。 "},"docs/会话和安全/和会话安全相关的配置项.html":{"url":"docs/会话和安全/和会话安全相关的配置项.html","title":"和会话安全相关的配置项","keywords":"","body":"和会话安全相关的配置项 session.cookie_lifetime session.use_only_cookies session.use_strict_mode session.cookie_httponly session.cookie_secure session.gc_maxlifetime session.use_trans_sid session.trans_sid_tags session.trans_sid_hosts session.referer_check session.cache_limiter session.sid_length session.sid_bits_per_character session.hash_function session.cookie_lifetime session.cookie_lifetime = 0 ，它告知浏览器不要持久化存储 Cookie 数据。也就是说，关闭浏览器的时候，会话 ID Cookie 会被立即删除。如果将此项设置为非 0 的值，可能会导致会话 ID 被其他用户使用。大部分应用应该把此项设置为 0 。如果应用中有自动登录的功能，请自行实现一种更加安全的方式，而不要使用长生命周期的会话 ID 来完成自动登录。 session.use_only_cookies session.use_only_cookies = 1 ，虽然 HTTP Cookie 存在一些问题，但是它确实是实现会话 ID 管理的优选方案。尽可能的仅使用 Cookie 来进行会话 ID 管理，而且大部分应用也确实是只使用 Cookie 来记录会话 ID 的。如果 session.use_only_cookies = 0 ，会话模块会在基于 Cookie 的会话 ID 初始化之前使用 GET / POST / URL 请求中的会话 ID 。 session.use_strict_mode session.use_strict_mode = 1 ，此设置防止会话模块使用未初始化的会话 ID 。也就是说，会话模块仅接受由它自己创建的有效的会话 ID ，而拒绝由用户自己提供的会话 ID 。攻击者可以自行设置 Cookie 或者使用 JavaScript 注入的方式来设置会话 ID 进行攻击。启用 session.use_strict_mode 配置项可以阻止使用未经会话模块初始化的会话 ID 。攻击者可以使用自己的设备产生会话 ID ，也可以使用受害者的会话 ID 。攻击者也可以通过一些后续操作保证会话活跃。因此，启用 session.use_strict_mode 配置项可以降低这种风险。 session.cookie_httponly session.cookie_httponly = 1 ，禁止 JavaScript 访问会话 Cookie 。此设置项可以保护 Cookie 不被 JavaScript 窃取。虽然可以使用会话 ID 来作为防范跨站请求伪造的关键数据，但是不建议这么做。例如，攻击者可以把 HTML 源代码保存下来并且发送给其他用户。为了安全起见，开发者不应该在 Web 页面中显示会话 ID 。 session.cookie_secure session.cookie_secure = 1 ，仅允许在 HTTPS 协议下访问会话 ID Cookie 。如果你的 Web 站点仅支持 HTTPS ，那么必须设置此配置项。对于仅支持 HTTPS 的 Web 站点建议考虑使用强制安全传输技术。 session.gc_maxlifetime session.gc_maxlifetime = 1440 ， session.gc_maxlifetime 来设置删除过期会话数据的时间周期。不建议依赖这个配置项来实现对于过期会话数据的删除，需要你自己来实现一套基于时间戳的会话数据生命周期管理机制。最好使用 session_gc() 函数来进行会话数据垃圾收集。如果是 Unix 操作系统，最好使用定时任务来执行 session_gc() 函数。会话数据删除的运行时机并不是精准的，带有一定的或然性，所以这个设置项并不能确保旧的会话数据被删除。虽然开发人员不能完全依赖这个设置，但是还是建议将其设置的尽可能的小。调整 session.gc_probability 和 session.gc_divisor 配置项可以使得过期的会话数据在适当的周期内被删除。如果需要使用自动登录的功能，请使用其他更加安全的方式自行实现，而不要通过使用长生命周期的会话 ID 来实现。 session.use_trans_sid session.use_trans_sid = 0 ，如果有需要，可以使用会话 ID 透传机制。但是，禁用会话 ID 透传机制可以 避免会话 ID 被注入以及泄漏，有效的提高会话安全性。会话 ID 可能在浏览器书签或者保存下来的 HTML 源代码中被泄漏。 session.trans_sid_tags session.trans_sid_tags = \"a=href,area=href,frame=src,form=\" ，一般情况下，默认值就可以，你无需重写不需要的标签。 session.trans_sid_hosts session.trans_sid_hosts = \"\" ，这个配置项设定允许进行会话 ID 透传的主机白名单。请勿在其中加入你不信任的主机。如果此配置项为空，则仅允许 $_SERVER['HTTP_HOST'] 的站点进行会话 ID 透传。 session.referer_check 当启用 session.use_trans_sid 配置项的时候，这个设置可以降低会话 ID 注入的风险。如果客户端发送了 Referer 信息但是在配置项中并未找到该子串，则嵌入的会话 ID 会被标记为无效。需要注意的是，如果使用了 HTTPS 协议， 那么浏览器在发起请求的时候不会包含 Referer 请求头。建议启用此配置项，虽然它并不是可靠的安全措施。 session.cache_limiter session.cache_limiter = nocache ，确保对于已经认证的会话，其 HTTP 内容不会被浏览器缓存。应该仅针对公开内容允许缓存，否则将会面临内容泄露的风险。即使 HTTP 内容不包含敏感数据，也可以把它设置为 session.cache_limiter = private 。 注意，这可能会导致客户端缓存私有数据。仅在 HTTP 内容中不包含任何私有数据的时候，可以设置为 session.cache_limiter = public 。 session.sid_length session.sid_length = 48 ，更长的会话 ID 可以得到更高的安全强度。 session.sid_bits_per_character session.sid_bits_per_character = 6 ，即使会话 ID 的长度设定不变，更高的会话 ID 比特位设置也会产生安全性更高的会话 ID 。 session.hash_function session.hash_function = sha256 ，高强度的哈希算法可以生成更高安全性的会话 ID 。 "},"docs/PHP 的命令行模式.html":{"url":"docs/PHP 的命令行模式.html","title":"PHP 的命令行模式","keywords":"","body":"PHP 的命令行模式 内置的 Web 服务器 和命令行模式相关的配置项 "},"docs/PHP 的命令行模式/内置的 Web 服务器.html":{"url":"docs/PHP 的命令行模式/内置的 Web 服务器.html","title":"内置的 Web 服务器","keywords":"","body":"内置的 Web 服务器 启动 Web 服务器 启动时指定根目录 使用路由脚本 启动 Web 服务器 切换到网站根目录，执行下面的命令可以启动 Web 服务器，访问 http://localhost:8080/ 即可预览网站。 php -S localhost:8080 启动时指定根目录 也可以执行下面的命令来指定网站根目录。 php -S localhost:8080 -t C:/Project/nginx-1.14.2/html/ 使用路由脚本 如果在启动 Web 服务器的时候指定了一个 PHP 文件，则这个文件会作为一个路由脚本，意味着每次请求都会先执行这个脚本。 php -S localhost:8080 router.php 如果这个路由脚本返回 false ，那么直接返回请求的文件，例如请求静态文件不作任何处理。否则会把输出返回到浏览器。 "},"docs/PHP 的命令行模式/和命令行模式相关的配置项.html":{"url":"docs/PHP 的命令行模式/和命令行模式相关的配置项.html","title":"和命令行模式相关的配置项","keywords":"","body":"和命令行模式相关的配置项 cli_server.color cli_server.color cli_server.color = On ，控制内置的 Web 服务器终端输出中使用 ANSI 颜色。 "},"docs/垃圾回收机制.html":{"url":"docs/垃圾回收机制.html","title":"垃圾回收机制","keywords":"","body":"垃圾回收机制 引用计数 "},"docs/垃圾回收机制/引用计数.html":{"url":"docs/垃圾回收机制/引用计数.html","title":"引用计数","keywords":"","body":"引用计数 "},"docs/PHP 类型比较表.html":{"url":"docs/PHP 类型比较表.html","title":"PHP 类型比较表","keywords":"","body":"PHP 类型比较表 使用函数比较 使用松散比较 使用严格比较 使用函数比较 表达式 gettype() empty() is_null() isset() if ($x) $x = ''; string true false true false $x = null; NULL true true false false $x; NULL true true false false unset($x); NULL true true false false $x = []; array true false true false $x = false; boolean true false true false $x = true; boolean false false true true $x = 1; integer false false true true $x = 42; integer false false true true $x = 0; integer true false true false $x = -1; integer false false true true $x = '1'; string false false true true $x = '0'; string true false true false $x = '-1'; string false false true true $x = 'php'; string false false true true $x = 'true'; string false false true true $x = 'false'; string false false true true 使用松散比较 true false 1 0 -1 '1' '0' '-1' NULL [] 'php' '' true true false true false true true false true false false true false false false true false true false false true false true true false true 1 true false true false false true false false false false false false 0 false true false true false false true false true false true true -1 true false false false true false false true false false false false '1' true false true false false true false false false false false false '0' false true false true false false true false false false false false '-1' true false false false true false false true false false false false NULL false true false true false false false false true true false true [] false true false false false false false false true true false false 'php' true false false true false false false false false false true false '' false true false true false false false false true false false true 使用严格比较 true false 1 0 -1 '1' '0' '-1' NULL [] 'php' '' true true false false false false false false false false false false false false false true false false false false false false false false false false 1 false false true false false false false false false false false false 0 false false false true false false false false false false false false -1 false false false false true false false false false false false false '1' false false false false false true false false false false false false '0' false false false false false false true false false false false false '-1' false false false false false false false true false false false false NULL false false false false false false false false true false false false [] false false false false false false false false false true false false 'php' false false false false false false false false false false true false '' false false false false false false false false false false false true "},"docs/PSR.html":{"url":"docs/PSR.html","title":"PSR","keywords":"","body":"PSR PSR-1 基础编码规范 PSR-2 编码风格规范 PSR-4 自动加载规范 "},"docs/PSR/PSR-1 基础编码规范.html":{"url":"docs/PSR/PSR-1 基础编码规范.html","title":"PSR-1 基础编码规范","keywords":"","body":"PSR-1 基础编码规范 文件 PHP 标签 字符编码 副作用 命名空间和类 类的常量、属性和方法 常量 属性 方法 文件 PHP 标签 PHP 代码 必须 使用 长标签或 短标签， 一定不可 使用其它自定义标签。 字符编码 PHP 代码 必须 使用 不带 BOM 的 UTF-8 编码。 副作用 一份 PHP 文件中 应该 要不就只定义新的声明，如类、函数或常量等不产生副作用的操作，要不就只书写会产生副作用的逻辑操作，但 不该 同时具有两者。 下面是一个包含函数声明以及产生副作用的例子： '; /** * Just a test function. * * @param void * @return void */ function foo() { // } 下面是一个只包含函数声明不产生副作用的例子： 命名空间和类 命名空间以及类的命名 必须 遵循 PSR-4 。 根据规范，每个类都独立为一个文件，且命名空间至少有一个层次：顶级的组织名称。 类的命名 必须 遵循 StudlyCaps 大写开头的驼峰命名规范。 类的常量、属性和方法 常量 类的常量中所有字母都 必须 大写，词间以下划线分隔。 属性 类的属性命名 可以 遵循：大写开头的驼峰式 $StudlyCaps 、小写开头的驼峰式 $camelCase 、下划线分隔式 $under_score 。 方法 类的方法名称 必须 符合 camelCase() 式的小写开头驼峰命名规范。 "},"docs/PSR/PSR-2 编码风格规范.html":{"url":"docs/PSR/PSR-2 编码风格规范.html","title":"PSR-2 编码风格规范","keywords":"","body":"PSR-2 编码风格规范 通则 基本编码准则 文件 行 缩进 关键字以及 true / false / null namespace 及 use 声明 类、属性和方法 扩展与继承 属性 方法 方法的参数 abstract 和 final 和 static 方法及函数调用 控制结构 if 和 elseif 和 else switch 和 case while 和 do-while for foreach try 和 catch 闭包 通则 基本编码准则 代码 必须 符合 PSR-1 中的所有规范。 文件 所有 PHP 文件 必须 使用 Unix 的 LF 作为行的结束符。 所有 PHP 文件 必须 以一个空白行作为结束。 纯 PHP 代码文件 必须 省略最后的 ?> 结束标签。 行 行的长度 一定不可 有硬性的约束。 软性的长度约束 必须 要限制在 120 个字符以内，若超过此长度，带代码规范检查的编辑器 必须 要发出警告，不过 一定不可 发出错误提示。 每行 不该 多于 80 个字符，大于 80 字符的行 应该 折成多行。 非空行后 一定不可 有多余的空格符。 空行 可以 使得阅读代码更加方便以及有助于代码的分块。 每行 一定不可 存在多于一条语句。 缩进 代码 必须 使用 4 个空格符的缩进， 一定不可 用 Tab 键。 关键字以及 true / false / null PHP 所有关键字 必须 全部小写。 常量 true 、 false 和 null 也 必须 全部小写。 namespace 及 use 声明 namespace 声明后 必须 插入一个空白行。 所有 use 必须 在 namespace 后声明。 每条 use 声明语句 必须 只有一个 use 关键词。 use 声明语句块后 必须 要有一个空白行。 类、属性和方法 扩展与继承 关键词 extends 和 implements 必须 写在类名称的同一行。 类的开始花括号 必须 独占一行，结束花括号也 必须 在类主体后独占一行。 implements 的继承列表也 可以 分成多行，这样的话，每个继承接口名称都 必须 分开独立成行，包括第一个。 属性 每个属性都 必须 添加访问修饰符。 一定不可 使用关键字 var 声明一个属性。 每条语句 一定不可 定义超过一个属性。 不该 使用下划线作为前缀，来区分属性是 protected 或 private 。 方法 所有方法都 必须 添加访问修饰符。 不该 使用下划线作为前缀，来区分方法是 protected 或 private 。 方法名称后 一定不可 有空格符，其开始花括号 必须 独占一行，结束花括号也 必须 在方法主体后单独成一行。参数左括号后和右括号前 一定不可 有空格。 方法的参数 参数列表中，每个逗号后面 必须 要有一个空格，而逗号前面 一定不可 有空格。 有默认值的参数， 必须 放到参数列表的末尾。 参数列表 可以 分列成多行，这样，包括第一个参数在内的每个参数都 必须 单独成行。 拆分成多行的参数列表后，结束括号以及方法开始花括号 必须 写在同一行，中间用一个空格分隔。 abstract 和 final 和 static 需要添加 abstract 或 final 声明时， 必须 写在访问修饰符前，而 static 则 必须 写在其后。 方法及函数调用 方法及函数调用时，方法名或函数名与参数左括号之间 一定不可 有空格，参数右括号前也 一定不可 有空格。每个参数前 一定不可 有空格，但其后 必须 有一个空格。 bar($arg1); Foo::bar($arg2, $arg3); 参数 可以 分列成多行，此时包括第一个参数在内的每个参数都 必须 单独成行。 bar( $longArgument, $longerArgument, $muchLongerArgument ); 控制结构 if 和 elseif 和 else switch 和 case case 语句 必须 相对 switch 进行一次缩进，而 break 语句以及 case 内的其它语句都 必须 相对 case 进行一次缩进。 如果存在非空的 case 语句，主体里 必须 有类似 // no break 的注释。 while 和 do-while for foreach $value) { // } try 和 catch 闭包 闭包声明时，关键词 function 后以及关键词 use 的前后都 必须 要有一个空格。 开始花括号 必须 写在声明的同一行，结束花括号 必须 紧跟主体结束的下一行。 参数列表和变量列表的左括号后以及右括号前， 一定不可 有空格。 参数和变量列表中，逗号前 一定不可 有空格，而逗号后 必须 要有空格。 闭包中有默认值的参数 必须 放到列表的后面。 参数列表以及变量列表 可以 分成多行，这样，包括第一个在内的每个参数或变量都 必须 单独成行，而列表的右括号与闭包的开始花括号 必须 放在同一行。 注意，闭包被直接用作函数或方法调用的参数时，以上规则仍然适用。 bar( $arg1, function ($arg2) use ($var) { // }, $arg3 ); "},"docs/PSR/PSR-4 自动加载规范.html":{"url":"docs/PSR/PSR-4 自动加载规范.html","title":"PSR-4 自动加载规范","keywords":"","body":"PSR-4 自动加载规范 一个完整的类名需具有以下结构： \\(\\)*\\ 完整的类名 必须 要有一个顶级命名空间。 完整的类名 可以 有一个或多个子命名空间。 完整的类名 必须 有一个最终的类名。 完整的类名中任意一部分中的下划线都是没有特殊含义的。 完整的类名 可以 由任意大小写字母组成。 所有类名都 必须 是大小写敏感的。 当根据完整的类名载入相应的文件： 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为命名空间前缀，其必须与至少一个文件主目录相对应。 紧接命名空间前缀后的子命名空间 必须 与相应的文件主目录相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名 必须 与对应的以 .php 为后缀的文件同名。 自动加载器的实现 一定不可 抛出异常、 一定不可 触发任一级别的错误信息以及 不应该 有返回值。 "}}